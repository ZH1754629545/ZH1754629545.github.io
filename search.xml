<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL 事务</title>
      <link href="/2025/08/25/SQL-%E4%BA%8B%E7%89%A9/"/>
      <url>/2025/08/25/SQL-%E4%BA%8B%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h1><h2 id="4个属性-ACID"><a href="#4个属性-ACID" class="headerlink" title="4个属性(ACID)"></a>4个属性(ACID)</h2><ul><li><strong>A：Atomicity</strong>，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li><li><strong>C：Consistency</strong>，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li><li><strong>I：Isolation</strong>，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li><li><strong>D：Durability</strong>，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li></ul><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<em>隐式事务</em>。</p><p>要手动把多条SQL语句作为一个事务执行，使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为<em>显式事务</em>.</p><h2 id="可能会出现的问题"><a href="#可能会出现的问题" class="headerlink" title="可能会出现的问题"></a>可能会出现的问题</h2><h3 id="Dirty-Read（脏读）"><a href="#Dirty-Read（脏读）" class="headerlink" title="Dirty Read（脏读）"></a>Dirty Read（脏读）</h3><p>指的是事物A在读取的时候读取到事物B刚刚更新但未提交的数据。</p><h3 id="Non-Repeatable-Read-不可重复读"><a href="#Non-Repeatable-Read-不可重复读" class="headerlink" title="Non Repeatable Read(不可重复读)"></a>Non Repeatable Read(不可重复读)</h3><p>指的是事物A在事物开始时查询某行数据，之后事物B执行了更新操作导致事物A再读的时候两边数据不一致。</p><h3 id="Phantom-Read（幻读）"><a href="#Phantom-Read（幻读）" class="headerlink" title="Phantom Read（幻读）"></a>Phantom Read（幻读）</h3><p>在同一个事务中，使用相同的查询条件多次查询时，后续查询返回了之前没有的新记录。</p><p>**幻读和不可重复读的区别：**幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同）。所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）；不可重复读是指读到了已经提交的事务的更改数据(修改)，幻读是指读到了其他已经提交事务的新增或删除数据。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。</p><p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p><table><thead><tr><th>Isolation Level</th><th>脏读（Dirty Read）</th><th>不可重复读（Non Repeatable Read）</th><th>幻读（Phantom Read）</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Read Committed</td><td>-</td><td>Yes</td><td>Yes</td></tr><tr><td>Repeatable Read</td><td>-</td><td>-</td><td>Yes</td></tr><tr><td>Serializable</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h3 id="Read-uncommitted-读未提交"><a href="#Read-uncommitted-读未提交" class="headerlink" title="Read uncommitted (读未提交)"></a>Read uncommitted (读未提交)</h3><p>  如果一个事务A已经开始写数据，则另一个事务B不允许写操作。但是可以读取这个事务A修改但未提交的数据。最低级别，任何情况都无法保证。</p><h3 id="Read-Committed-读已提交"><a href="#Read-Committed-读已提交" class="headerlink" title="Read Committed (读已提交)"></a>Read Committed (读已提交)</h3><p>  事务A只能读取事务B修改并且提交后的数据行，禁止访问事务B处于写状态的数据行。可以避免脏读。</p><h3 id="Repeatable-Read（可重复读取）"><a href="#Repeatable-Read（可重复读取）" class="headerlink" title="Repeatable Read（可重复读取）"></a>Repeatable Read（可重复读取）</h3><p>  事务A在读取数据行时，禁止其他事务对该数据行进行更改，但是可以进行读取操作。进行写操作时，禁止其他事务的任何操作。可以防止脏读和不可重复读。</p><h3 id="Serializable-可串行化"><a href="#Serializable-可串行化" class="headerlink" title="Serializable (可串行化)"></a>Serializable (可串行化)</h3><p>  提供严格的隔离级别，要求事务一个个的执行。不能并发执行。有效的防止脏读，不可重复读，幻读。</p>]]></content>
      
      
      <categories>
          
          <category> sql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
            <tag> 事物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础(三) 线程池</title>
      <link href="/2025/08/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-%E4%B8%89-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2025/08/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-%E4%B8%89-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h1><p>Java语言虽然内置了多线程支持，启动一个新线程非常方便，但是，创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。<br>所以引入了<strong>线程池</strong>的概念。</p><p>简单地说，线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p>Java标准库提供了<code>ExecutorService</code>接口表示线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建固定大小的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//提交任务</span></span><br><span class="line">    executorService.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(Integer.toString(i)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure><p>这里首先会执行</p><p>前三个任务，其他的任务会入队列等待，然后等待任务执行完再从任务队列一个个取出来。</p><p>执行<code>executorService.shutdown();</code> 他会等待线程所有线程执行完才会关闭。但不回阻塞语句。<br><code>executorService.shutdownNow();</code>执行这段他会立即停止正在执行的线程。<br><code>awaitTermination(long timeout, TimeUnit unit)</code> 它会根据传入的参数，检测超过设置的时长时线程池会不会结束。如果没结束返回false.</p><p><strong>组合使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//创建固定大小的线程池</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//提交任务</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(Integer.toString(i)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(!executorService.awaitTermination(<span class="number">3</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line"></span><br><span class="line">           System.out.println(<span class="string">&quot;线程池还未关闭即将强制关闭线程池&quot;</span>);</span><br><span class="line">           executorService.shutdownNow();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果我们想把线程池的大小限制在4～10个之间动态调整怎么办？</strong><br>使用<code>CachedThreadPool</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(min, max,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;()</span><br><span class="line">       );</span><br></pre></td></tr></table></figure><p>这样就能动态创建4-15个线程。<br>但是这里用的时 SynchronousQueue<Runnable>这是一个没有容量的队列。所以一但超过max就会抛出异常。<br><a href="https://zhuanlan.zhihu.com/p/682382113">Java并发基础：SynchronousQueue全面解析！ - 知乎</a></Runnable></p><h2 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h2><p><strong>这里可以使用拒绝执行策略</strong><code>CallerRunsPolicy</code></p><p>这样就可有把超出的数量放在之前的创建的线程中，不过这样会影响性能。<br>callerRunsPolicy他会在线程超出范围时执行把任务丢给哪个执行它的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(min, max,</span><br><span class="line">            <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()</span><br><span class="line">           );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(Integer.toString(i)));</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">start  :   10   Threadmain</span><br><span class="line">start  :   1   Threadpool-1-thread-2</span><br><span class="line">start  :   7   Threadpool-1-thread-8</span><br><span class="line">start  :   6   Threadpool-1-thread-7</span><br><span class="line">start  :   5   Threadpool-1-thread-6</span><br><span class="line">start  :   4   Threadpool-1-thread-5</span><br><span class="line">start  :   0   Threadpool-1-thread-1</span><br><span class="line">start  :   9   Threadpool-1-thread-10</span><br><span class="line">start  :   8   Threadpool-1-thread-9</span><br><span class="line">start  :   2   Threadpool-1-thread-3</span><br><span class="line">start  :   3   Threadpool-1-thread-4</span><br><span class="line">end   :   7</span><br><span class="line">end   :   10</span><br><span class="line">end   :   1</span><br><span class="line">start  :   11   Threadmain</span><br><span class="line">end   :   0</span><br><span class="line">end   :   5</span><br><span class="line">end   :   2</span><br><span class="line">end   :   8</span><br><span class="line">end   :   9</span><br><span class="line">end   :   3</span><br><span class="line">end   :   4</span><br><span class="line">end   :   6</span><br><span class="line">end   :   11</span><br><span class="line">start  :   12   Threadpool-1-thread-7</span><br><span class="line">start  :   14   Threadpool-1-thread-4</span><br><span class="line">start  :   13   Threadpool-1-thread-5</span><br><span class="line">end   :   12</span><br><span class="line">end   :   13</span><br><span class="line">end   :   14</span><br></pre></td></tr></table></figure><p>演示一下执行过程：</p><ol><li>创建线程池设置参数</li><li>for循环从0-9 线程池执行任务此时线程池已经满了。</li><li>for循环到第10个时，SynchronousQueue无法存储任务。所以直接丢给main线程来执行，for循环阻塞。</li><li>当main线程执行完task时，发现还没有线程空闲，main线程继续执行第11个任务。</li><li>当main线程执行完第11个任务，发现有线程空闲，将后面的线程继续往空闲的线程里放。</li></ol><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>或者可以使用有界队列 <strong>LinkedBlockingQueue&lt;&gt;(‘队列大小’)</strong><br>可以指定队列存储任务的大小，也可以不指定(无限)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int min = 4;</span><br><span class="line">    int max = 5;</span><br><span class="line">    ExecutorService executorService = new ThreadPoolExecutor(min, max,</span><br><span class="line">            60L, TimeUnit.SECONDS,</span><br><span class="line">            new LinkedBlockingQueue&lt;&gt;(10),</span><br><span class="line">            new ThreadPoolExecutor.CallerRunsPolicy()</span><br><span class="line">           );</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 15; i++) &#123;</span><br><span class="line">        executorService.submit(new Task(Integer.toString(i)));</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h2><p>还有一种任务，需要定期反复执行，例如，每秒刷新证券价格。这种任务本身固定，需要反复执行的，可以使用<code>ScheduledThreadPool</code>。放入<code>ScheduledThreadPool</code>的任务可以定期反复执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//指定延迟1s后执行</span></span><br><span class="line">    scheduledExecutorService.schedule(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;one-time&quot;</span>),<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定延迟2s后执行，每3s执行一次</span></span><br><span class="line">    scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;fixed-rate&quot;</span>),<span class="number">2</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2秒后开始执行定时任务，以3秒为间隔执行:</span></span><br><span class="line">    scheduledExecutorService.scheduleWithFixedDelay(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;fixed-delay&quot;</span>),<span class="number">2</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意FixedRate和FixedDelay的区别。FixedRate是指任务总是以固定时间间隔触发，不管任务执行多长时间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">│░░░░   │░░░░░░ │░░░    │░░░░░  │░░░  </span><br><span class="line">├───────┼───────┼───────┼───────┼────▶</span><br><span class="line">│◀─────▶│◀─────▶│◀─────▶│◀─────▶│</span><br></pre></td></tr></table></figure><p>而FixedDelay是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">│░░░│       │░░░░░│       │░░│       │░</span><br><span class="line">└───┼───────┼─────┼───────┼──┼───────┼──▶</span><br><span class="line">    │◀─────▶│     │◀─────▶│  │◀─────▶│</span><br></pre></td></tr></table></figure><p>因此，使用<code>ScheduledThreadPool</code>时，我们要根据需要选择执行一次、FixedRate执行还是FixedDelay执行。</p><p><strong>注意</strong>:在使用FixedRate如果任务执行时间超过了固定触发时间。那么就不会执行新任务，会等待。指导任务完成后立马触发任务。<br>FixedDelay中超过时间，则会等待任务完成后再等待指定时间触发任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(min, max,</span><br><span class="line">                <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()</span><br><span class="line">        );</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//指定延迟1s后执行</span></span><br><span class="line"><span class="comment">//        scheduledExecutorService.schedule(new Task(&quot;one-time&quot;),1,TimeUnit.SECONDS);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定延迟2s后执行，每3s执行一次</span></span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;fixed-rate&quot;</span>));</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2秒后开始执行定时任务，以3秒为间隔执行:</span></span><br><span class="line"><span class="comment">//        scheduledExecutorService.scheduleWithFixedDelay(new Task(&quot;fixed-delay&quot;),1,2,TimeUnit.SECONDS);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样就可以异步执行</p><p><strong>一旦任务抛出未捕获的异常，该定时任务就会被永久停止，不会再继续执行后续的调度。</strong></p><h1 id="使用Future"><a href="#使用Future" class="headerlink" title="使用Future"></a>使用Future</h1><p>在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。我们提交的任务只需要实现<code>Runnable</code>接口，就可以让线程池去执行<br><code>Runnable</code>接口有个问题，它的方法没有返回值。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。所以，Java标准库还提供了一个<code>Callable</code>接口，和<code>Runnable</code>接口比，它多了一个返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task1</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>().toLocaleString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>并且<code>Callable</code>接口是一个泛型接口，可以返回指定类型的结果。</p><p>现在的问题是，如何获得异步执行的结果？</p><p>如果仔细看<code>ExecutorService.submit()</code>方法，可以看到，它返回了一个<code>Future</code>类型，一个<code>Future</code>类型的实例代表一个未来能获取结果的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//定义任务</span></span><br><span class="line">    Callable&lt;String&gt; task1 = <span class="keyword">new</span> <span class="title class_">Task1</span>();</span><br><span class="line">    <span class="comment">//提交任务并获取future</span></span><br><span class="line">    Future&lt;String&gt;future = es.submit(task1);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> future.get();</span><br><span class="line">    System.out.println(res);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们提交一个<code>Callable</code>任务后，我们会同时获得一个<code>Future</code>对象，然后，我们在主线程某个时刻调用<code>Future</code>对象的<code>get()</code>方法，就可以获得异步执行的结果。在调用<code>get()</code>时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么<code>get()</code>会阻塞，直到任务完成后才返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    Callable&lt;String&gt;ca = <span class="keyword">new</span> <span class="title class_">Task1</span>();</span><br><span class="line">    Future&lt;String&gt; fu=es.submit(ca);</span><br><span class="line">    System.out.println(fu.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输出结果:</span><br><span class="line">2025年8月17日 15:20:15</span><br><span class="line">2025年8月17日 15:20:16</span><br><span class="line">2025年8月17日 15:20:17</span><br><span class="line">2025年8月17日 15:20:18</span><br><span class="line">2025年8月17日 15:20:19</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="使用CompletableFuture"><a href="#使用CompletableFuture" class="headerlink" title="使用CompletableFuture"></a>使用CompletableFuture</h1><p>使用<code>Future</code>获得异步执行结果时，要么调用阻塞方法<code>get()</code>，要么轮询看<code>isDone()</code>是否为<code>true</code>，这两种方法都不是很好，因为主线程也会被迫等待。</p><p>从Java 8开始引入了<code>CompletableFuture</code>，它针对<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompFu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建异步任务</span></span><br><span class="line">        CompletableFuture&lt;Double&gt; cf  = CompletableFuture.supplyAsync(CompFu::getP);</span><br><span class="line">        <span class="comment">// 如果执行成功:</span></span><br><span class="line">        cf.thenAccept((result) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;price: &quot;</span> + result);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 如果执行异常:</span></span><br><span class="line">        cf.exceptionally((e) -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getP</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;fetch price failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> + Math.random() * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个<code>CompletableFuture</code>是通过<code>CompletableFuture.supplyAsync()</code>实现的，它需要一个实现了<code>Supplier</code>接口的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们用lambda语法简化了一下，直接传入<code>Main::fetchPrice</code>，因为<code>Main.fetchPrice()</code>静态方法的签名符合<code>Supplier</code>接口的定义（除了方法名外）。</p><p>紧接着，<code>CompletableFuture</code>已经被提交给默认的线程池执行了，我们需要定义的是<code>CompletableFuture</code>完成时和异常时需要回调的实例。完成时，<code>CompletableFuture</code>会调用<code>Consumer</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常时，<code>CompletableFuture</code>会调用<code>Function</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们都用lambda语法简化了代码。</p><p>可见<code>CompletableFuture</code>的优点是：</p><ul><li>异步任务结束时，会自动回调某个对象的方法；</li><li>异步任务出错时，会自动回调某个对象的方法；</li><li>主线程设置好回调后，不再关心异步任务的执行。</li></ul><p><strong>ComletableFuture</strong>和<strong>Future</strong>相比起来优势是ComletableFuture可以串行执行。可以根据流程一步一步往下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//创建异步任务1 查询Id</span></span><br><span class="line">    CompletableFuture&lt;Long&gt; cfQueryId  = CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1l</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    Map&lt;Long,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1l</span>,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    <span class="comment">//创建异步任务2 根据收到的Id去查询对应的参数</span></span><br><span class="line">    CompletableFuture&lt;String&gt;cfQueryById = cfQueryId.thenApplyAsync((id)-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取Id:&quot;</span> +id);</span><br><span class="line">        <span class="keyword">return</span> map.get(id);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果执行成功:</span></span><br><span class="line">    cfQueryById.thenAccept((res)-&gt;&#123;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//如果执行失败</span></span><br><span class="line">    cfQueryById.exceptionally((e)-&gt;&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外出了串行功能它还能提供并行。<br>比如从a,b方法并行获取某个代码，只要获取成功其中一个，那就调用c方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompFU1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//两个CompletableFuture 并行查询Id</span></span><br><span class="line">        CompletableFuture&lt;Long&gt; getIdByMethod1 = CompletableFuture.supplyAsync(()-&gt;getId(<span class="string">&quot;method1&quot;</span>));</span><br><span class="line">        CompletableFuture&lt;Long&gt; getIdByMethod2 = CompletableFuture.supplyAsync(()-&gt;getId(<span class="string">&quot;method2&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//合并两个两个CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;Object&gt; getId = CompletableFuture.anyOf(getIdByMethod1,getIdByMethod2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个异步查询结果</span></span><br><span class="line">        CompletableFuture&lt;String&gt;cfFetch=getId.thenApply((res)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> getById((Long) res);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        cfFetch.thenAccept((res)-&gt;&#123;</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getId</span><span class="params">(String param)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;source from &quot;</span> + param);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1l</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getById</span><span class="params">(Long id)</span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Long,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1l</span>,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了<code>anyOf()</code>可以实现“任意个<code>CompletableFuture</code>只要一个成功”，<code>allOf()</code>可以实现“所有<code>CompletableFuture</code>都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。</p><p>最后我们注意<code>CompletableFuture</code>的命名规则：</p><ul><li><code>xxx()</code>：表示该方法将继续在已有的线程中执行；</li><li><code>xxxAsync()</code>：表示将异步在线程池中执行。</li></ul><h1 id="使用ForkJoin"><a href="#使用ForkJoin" class="headerlink" title="使用ForkJoin"></a>使用ForkJoin</h1><p>Java 7开始引入了一种新的Fork&#x2F;Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。</p><p><strong>Fork&#x2F;Join任务的原理</strong>：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。<br>利用了分治的思想，实现起来和二分差不多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.threadPoor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span>: ForkJ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ZH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/8/17 15:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJ</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建两千长度数据，求和</span></span><br><span class="line">        <span class="type">long</span>[] arr = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">2000</span>];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">res1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] =  random.nextLong(<span class="number">100</span>);</span><br><span class="line">            res1 += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Exception res:  &quot;</span>+res1);</span><br><span class="line">        <span class="comment">//使用fork/join</span></span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> <span class="title class_">SumTask</span>(arr,<span class="number">0</span>,arr.length);</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> ForkJoinPool.commonPool().invoke(task);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="type">long</span>[] array;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    SumTask(<span class="type">long</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(end-start&lt;THRESHOLD)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//足够小直接计算</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">                sum+=array[i];</span><br><span class="line">                <span class="comment">// 故意放慢计算速度:</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start+end&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;</span>, start, end, start, mid, mid, end));</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">sumTask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="built_in">this</span>.array,start,mid);</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">sumTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="built_in">this</span>.array,mid,end);</span><br><span class="line">        invokeAll(sumTask1,sumTask2);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">stRes1</span> <span class="operator">=</span> sumTask1.join();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">stRes2</span> <span class="operator">=</span> sumTask2.join();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">res</span> <span class="operator">=</span> stRes1+stRes2;</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + stRes1 + <span class="string">&quot; + &quot;</span> + stRes2 + <span class="string">&quot; ==&gt; &quot;</span> + res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Exception res:  98589</span><br><span class="line">split 0~2000 ==&gt; 0~1000, 1000~2000</span><br><span class="line">split 0~1000 ==&gt; 0~500, 500~1000</span><br><span class="line">split 0~500 ==&gt; 0~250, 250~500</span><br><span class="line">split 1000~2000 ==&gt; 1000~1500, 1500~2000</span><br><span class="line">split 500~1000 ==&gt; 500~750, 750~1000</span><br><span class="line">线程：ForkJoinPool.commonPool-worker-1</span><br><span class="line">split 1000~1500 ==&gt; 1000~1250, 1250~1500</span><br><span class="line">线程：ForkJoinPool.commonPool-worker-4</span><br><span class="line">线程：ForkJoinPool.commonPool-worker-2</span><br><span class="line">线程：ForkJoinPool.commonPool-worker-5</span><br><span class="line">线程：ForkJoinPool.commonPool-worker-3</span><br><span class="line">split 1500~2000 ==&gt; 1500~1750, 1750~2000</span><br><span class="line">线程：ForkJoinPool.commonPool-worker-7</span><br><span class="line">线程：ForkJoinPool.commonPool-worker-6</span><br><span class="line">线程：ForkJoinPool.commonPool-worker-8</span><br><span class="line">result = 12016 + 12618 ==&gt; 24634</span><br><span class="line">result = 11902 + 12429 ==&gt; 24331</span><br><span class="line">result = 12089 + 13162 ==&gt; 25251</span><br><span class="line">result = 11928 + 12445 ==&gt; 24373</span><br><span class="line">result = 24331 + 24634 ==&gt; 48965</span><br><span class="line">result = 24373 + 25251 ==&gt; 49624</span><br><span class="line">result = 49624 + 48965 ==&gt; 98589</span><br><span class="line">Fork/join sum: 98589 in 367 ms.</span><br></pre></td></tr></table></figure><p>由于ForkJoinPool 能够根据系统资源情况自动调整线程数量，所以用户不需要手动指定线程数量。如果手动指定线程数量，可能会导致线程数不足或过多，从而影响并行计算的效率.﻿</p><h1 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h1><p>多线程是Java实现多任务的基础，<code>Thread</code>对象代表一个线程，我们可以在代码中调用<code>Thread.currentThread()</code>获取当前线程。例如，打印日志时，可以同时打印出当前线程的名字。<br>使用<strong>ThreadLocal</strong> 相当于在这个线程中添加了一个全局的缓存变量。可以随时取用，不需要在传参的时候作为参数传递.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadL</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocalString = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadL</span> <span class="variable">threadL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadL</span>();</span><br><span class="line">        threadL.process(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String s)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            threadLocalString.set(s);</span><br><span class="line">            doWork1();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//清除ThreadLocal</span></span><br><span class="line">            threadLocalString.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        doWork1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> threadLocalString.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;获得&quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果如下:</span><br><span class="line"></span><br><span class="line">获得1111</span><br><span class="line">获得null</span><br></pre></td></tr></table></figure><p>最后，特别注意<code>ThreadLocal</code>一定要在<code>finally</code>中清除：</p><p>这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果<code>ThreadLocal</code>没有被清除，该线程执行其他代码时，会把上一次的状态带进去。</p><p>为了保证能释放<code>ThreadLocal</code>关联的实例，我们可以通过<code>AutoCloseable</code>接口配合<code>try (resource) &#123;...&#125;</code>结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的<code>ThreadLocal</code>可以封装为一个<code>StringContext</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringContext</span> <span class="keyword">implements</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; key = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StringContext</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringContext</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StringContext</span><span class="params">()</span> &#123;&#125; <span class="comment">// 私有构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringContext <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        key.set(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            StringContext.getInstance().set(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            process();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            StringContext.getInstance().set(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            process();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(StringContext.getInstance().get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结果:</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h1 id="使用虚拟线程"><a href="#使用虚拟线程" class="headerlink" title="使用虚拟线程"></a>使用虚拟线程</h1><p>当传统线程遇到了IO密集型的任务，比如：HTTP请求，文件读写受网络，磁盘速度影响线程会等待。这样就会浪费线程资源，导致了CPU的利用率其实没有达到理想状态。</p><p>而虚拟线程则是在线程遇到I&#x2F;O阻塞时，会放暂时放弃等待去做其他事，等I&#x2F;O完成它才会回来继续执行任务，无疑这种方式提高了CPU的利用率，让它无法再偷懒。<br>虚拟线程是由JVM来管理的，不由系统管理，并且它十分<code>轻量</code>，虚拟线程之间的切换开销十分的小，所以你甚至可以开启上百万个虚拟线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.threadPoor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span>: ThreadVir</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ZH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/8/17 17:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadVirtual</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TASK_COUNT</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">// 大量任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">IO_DELAY_MS</span> <span class="operator">=</span> <span class="number">100</span>;  <span class="comment">// 模拟IO等待100ms</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=== 虚拟线程 vs 平台线程 IO密集型任务对比 ===\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试虚拟线程</span></span><br><span class="line">        testVirtualThreads();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试平台线程</span></span><br><span class="line">        testPlatformThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testVirtualThreads</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 虚拟线程测试 - &quot;</span> + TASK_COUNT + <span class="string">&quot; 个任务&quot;</span>);</span><br><span class="line">        <span class="type">Instant</span> <span class="variable">start</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">            IntStream.range(<span class="number">0</span>, TASK_COUNT).forEach(i -&gt; &#123;</span><br><span class="line">                executor.submit(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 模拟IO等待（比如网络请求、文件读取等）</span></span><br><span class="line">                        Thread.sleep(IO_DELAY_MS);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 简单计算任务</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i * i;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (i &lt; <span class="number">10</span>) &#123; <span class="comment">// 只打印前10个任务的信息</span></span><br><span class="line">                            System.out.printf(<span class="string">&quot;虚拟线程任务 %d 完成，结果: %d, 线程: %s%n&quot;</span>,</span><br><span class="line">                                    i, result, Thread.currentThread().getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="comment">// 自动等待所有任务完成并关闭</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(start, Instant.now());</span><br><span class="line">        System.out.printf(<span class="string">&quot;虚拟线程总耗时: %d 毫秒%n&quot;</span>, duration.toMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPlatformThreads</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 平台线程测试 - &quot;</span> + TASK_COUNT + <span class="string">&quot; 个任务&quot;</span>);</span><br><span class="line">        <span class="type">Instant</span> <span class="variable">start</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建固定大小的线程池（通常建议CPU核心数的2-4倍）</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">200</span>)) &#123;</span><br><span class="line">            IntStream.range(<span class="number">0</span>, TASK_COUNT).forEach(i -&gt; &#123;</span><br><span class="line">                executor.submit(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 同样的IO等待</span></span><br><span class="line">                        Thread.sleep(IO_DELAY_MS);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 同样的计算任务</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i * i;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                            System.out.printf(<span class="string">&quot;平台线程任务 %d 完成，结果: %d, 线程: %s%n&quot;</span>,</span><br><span class="line">                                    i, result, Thread.currentThread().getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            executor.shutdown();</span><br><span class="line">            executor.awaitTermination(<span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(start, Instant.now());</span><br><span class="line">        System.out.printf(<span class="string">&quot; 平台线程总耗时: %d 毫秒%n&quot;</span>, duration.toMillis());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总而言之，在拥有大量线程IO导致线程堵塞，cpu利用率不高时，可以使用虚拟线程来解决。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础(二)</title>
      <link href="/2025/08/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-%E4%BA%8C/"/>
      <url>/2025/08/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>当多个线程同时运行时，先后顺序有系统去调动，程序无法决定。因此，在多线程环境下就可能造成一些问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadA</span>();</span><br><span class="line">        <span class="type">var</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadB</span>();</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        a.join();</span><br><span class="line">        b.join();</span><br><span class="line">        System.out.println(Counter.counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadA</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            Counter.counter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadB</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            Counter.counter--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中如果按照正常人逻辑来看这个最后的结果为0，但是最后的结果每次都会不一样。因为这些操作顺序都不是固定的。比如一开始counter是0执行一次++的途中执行完毕了两次–，此时counter是-2但是我counter++是拿0去加最后变回了1赋值上去了。<br><strong>对于一条语句n&#x3D;n+1</strong></p><p>执行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><p>加锁，保证操作的原子性。synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (Counter.lock)&#123;</span><br><span class="line">Counter.counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (Counter.lock)&#123;</span><br><span class="line">Counter.counter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样保证了原子性。缺点就是性能会下降</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SharedList</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    <span class="type">AtomicBoolean</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">                str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.compareAndSet(<span class="literal">true</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">                str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (str) &#123;</span><br><span class="line">                System.out.print(str.charAt(<span class="number">0</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                System.out.print(str.charAt(<span class="number">1</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                System.out.println(str.charAt(<span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SharedList</span> <span class="variable">sharedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SharedList</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(sharedList::write).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(sharedList::read).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这段代码他还是会输出<br>a 2 c<br>a b c<br>a b 3<br>1 b 3<br>a 2 3<br><strong>明明string 是线性安全的但是为什么会这样呢？</strong></p><p>因为当前锁的是str的那个对象。由于string 里是这样的private final byte[] value;<br>所以在赋值操作时实际上是new 了一个string。锁住的对象不同那当然没办法正确的输出</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>Java的线程锁是可重入的锁。<br>意思就是当我这个方法获得这个锁时可以再利用这个锁进入另一个方法。这种能被同一个线程反复获取的锁，就叫做<strong>可重入锁</strong>。<br>这种锁不仅要判断是否是第一次获取，还要记录是第几次获取。每获取一次记录+1.每退出一次记录-1.相当于入度。减到0是才会释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dec(-n);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        count += n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：在同一个进程内防止自锁死。如果a方法上了锁，b方法也有个加锁。a调用b方法。如果没有这个可重入的锁的东西那么就会自己给自己卡死。有了这个东西，这样一来，无论是哪个线程调用b方法都不会给自己卡死。</p><p><strong>死锁</strong></p><p>一个线程可以获取一个锁后，再继续获取另一个锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger k= <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">       k.getAndIncrement();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line"></span><br><span class="line">           k.getAndDecrement();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">        k.getAndDecrement();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">            k.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread1.start();</span><br><span class="line">thread2.start();</span><br></pre></td></tr></table></figure><p><strong>如何解决？</strong></p><p>保证逻辑不冲突就行，比如Thread2改成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lockA)&#123;</span><br><span class="line">        k.getAndDecrement();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockB)&#123;</span><br><span class="line">            k.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="使用wait和notify"><a href="#使用wait和notify" class="headerlink" title="使用wait和notify"></a>使用wait和notify</h2><p>简单来说当线程使用**wait()<strong>的时候会释放锁。比如this.wait()就会释放this。然后等待其他线程去唤醒他，使用</strong>notify()<strong>或</strong>notifyAll()**去唤醒锁。<br>使用<code>notifyAll()</code>将唤醒所有当前正在<code>this</code>锁等待的线程，而<code>notify()</code>只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。这是因为可能有多个线程正在<code>getTask()</code>方法内部的<code>wait()</code>中等待，使用<code>notifyAll()</code>将一次性全部唤醒。通常来说，<code>notifyAll()</code>更安全。有些时候，如果我们的代码逻辑考虑不周，用<code>notify()</code>会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        queue.add(s);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.isEmpty())&#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创造一个任务队列，里面方法add和get有加锁。如果没有这个wait()那么执行getTask()方法时就会进入 while (queue.isEmpty())死循环一直不释放锁。这样程序就不会结束了。</p><p>当使用 this.wait();时这个方法会把this的锁给释放掉。此时addTask可以进入使用add方法，接着唤醒所有的锁。所有的getTask()被唤醒再去抢夺这个锁，继续执行。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>从Java 5开始，引入了一个高级的处理并发的<code>java.util.concurrent</code>包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p><p>java中synchronized用于加锁，但是这个锁操作不太方便，获取时必须等待，没有额外的尝试机制。<br><code>java.util.concurrent.locks</code>包提供的<code>ReentrantLock</code>用于替代<code>synchronized</code>加锁。</p><p><strong>使用ReentrantLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter1</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;+&quot;</span>+n);</span><br><span class="line">        count+=n;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code>是可重入锁，它和<code>synchronized</code>一样，一个线程可以多次获取同一个锁</p><p><code>ReentrantLock</code>可以尝试获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> n)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span>(lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;+&quot;</span>+n);</span><br><span class="line">            count+=n;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此处为如果2s后仍未获得到锁，tryLock（）会返回false程序就可以做一些额外处理，而不是无限等待下去。</p><p>所以，使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，线程在<code>tryLock()</code>失败的时候不会导致死锁。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p><strong>synchronized</strong>中我们使用wait()和notify()去实现不满足条件时等待，满足条件时唤醒。<br>在<strong>ReentrantLock</strong> 中同样的也有实现方法：<strong>Condition</strong></p><p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p><ul><li><code>await()</code>会释放当前锁，进入等待状态；</li><li><code>signal()</code>会唤醒某个等待线程；</li><li><code>signalAll()</code>会唤醒所有等待线程；</li><li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue1</span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addTask</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.remove();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<code>tryLock()</code>类似，<code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition.await(1, TimeUnit.SECOND)) &#123;</span><br><span class="line">    // 被其他线程唤醒</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 指定时间内没有被其他线程唤醒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReadWriteLock（读写锁）"><a href="#ReadWriteLock（读写锁）" class="headerlink" title="ReadWriteLock（读写锁）"></a>ReadWriteLock（读写锁）</h2><p>单纯的使用lock在某些情况会导致保护过头。比如读写操作。如果只是大量并发读操作根本没必要加锁卡住其他的读操作。只需要在有读操作时卡住其他线程的读写操作就行。<br>因此引入了读写锁ReadWriteLock<br><strong>基本实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">rLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">wLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        wLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            counts[id]++;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            wLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        rLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(counts[id]);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            rLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以理解为当写的操作在进行时其他相同类型的lock就会阻塞(包括他自己)。但是在读操作进行时可以进来相同的读操作（写不行）。</p><h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>对比于ReadWriteLock（读写锁）来说性能更提升了一步。在ReadWriteLock中当你在读取的时候是无法进行写操作的，这是一种悲观的读锁。</p><p>要进一步提升并发执行效率，Java 8引入了新的读写锁：<code>StampedLock</code></p><p>这样以来就可以在读的过程中插入写操作。不过这样的话需要额外判断并处理这次写操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">stampedLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> xx, <span class="type">double</span> yy)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.writeLock(); <span class="comment">//获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x+=xx;</span><br><span class="line">            y+=yy;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> stampedLock.tryOptimisticRead(); <span class="comment">//乐观读锁</span></span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentX</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="type">double</span> <span class="variable">currentY</span> <span class="operator">=</span> y;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stampedLock.validate(stamp))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;触发写&quot;</span>);</span><br><span class="line">            stamp = stampedLock.readLock();<span class="comment">//悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX*currentX+currentY*currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore是一种可以控制资源受限的锁。他能保证同一时刻最多只有N个线程能访问。像前面的(ReentrantLock)只能同一时间只能一个资源访问。读写锁(ReadWriteLock)只能一个线程写入，但是读不受控制。<br>如果用Lock数组来实现就太麻烦了<br>所以这里引入Semaphore。可以直接设置能有几个线程同时访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccessLimit</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">access</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tryAccess</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span>(semaphore.tryAcquire(<span class="number">5</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和ReentrantLock一样他是有try方法的</p><p>不同的是他并不是一个可重入的锁。每次semaphore.acquire();都会消耗一个。</p><h2 id="Concurrent集合"><a href="#Concurrent集合" class="headerlink" title="Concurrent集合"></a>Concurrent集合</h2><p>之前使用了<strong>ReentrantLock</strong> + <strong>Condition</strong> 制作了一个BlockingQueue。<br><code>BlockingQueue</code>的意思就是说，当一个线程调用这个<code>TaskQueue</code>的<code>getTask()</code>方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，<code>getTask()</code>方法才会返回。</p><p>因为<code>BlockingQueue</code>非常有用，所以我们不必自己编写，可以直接使用Java标准库的<code>java.util.concurrent</code>包提供的线程安全的集合：<code>ArrayBlockingQueue</code></p><p>除了<code>BlockingQueue</code>外，针对<code>List</code>、<code>Map</code>、<code>Set</code>、<code>Deque</code>等，<code>java.util.concurrent</code>包也提供了对应的并发集合类。</p><p><strong>例如java.util.concurrent.ConcurrentHashMap</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; mapThreadSafe = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"> Map&lt;String,Integer&gt; mapThreadUnsafe = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 增加操作复杂度和并发压力</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">         <span class="comment">// 大量操作</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">             mapThreadSafe.put(<span class="string">&quot;key&quot;</span> + (index * <span class="number">1000</span> + j), j);</span><br><span class="line">             mapThreadUnsafe.put(<span class="string">&quot;key&quot;</span> + (index * <span class="number">1000</span> + j), j);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Thread.sleep(<span class="number">2000</span>); <span class="comment">// 等待所有线程完成</span></span><br><span class="line"> System.out.println(<span class="string">&quot;Safe size: &quot;</span> + mapThreadSafe.size());</span><br><span class="line"> System.out.println(<span class="string">&quot;Unsafe size: &quot;</span> + mapThreadUnsafe.size());</span><br></pre></td></tr></table></figure><p><strong>输出结果如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Safe size: 1000000</span><br><span class="line">Unsafe size: 694319</span><br></pre></td></tr></table></figure><p><strong>原因</strong></p><p>HashMap&lt;&gt;()并不是线程安全的类，也就是说它的put不能保证安全性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap的put方法大致流程：</span><br><span class="line">1. 计算hash值</span><br><span class="line">2. 定位数组位置</span><br><span class="line">3. 检查是否需要扩容</span><br><span class="line">4. 插入或更新节点</span><br><span class="line">5. 更新size</span><br></pre></td></tr></table></figure><p>也就是说很有可能在两个线程同时将数据插入的时候，插入到一个数组导致数据覆盖。或者在更新size的值的时候，原本是size()&#x3D;&#x3D;100，两个线程同时更新size()最后变成101</p><h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p>Java的<code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于<code>java.util.concurrent.atomic</code>包</p><p>以<code>AtomicInteger</code>为例，它提供的主要操作有：</p><ul><li>增加值并返回新值：<code>int addAndGet(int delta)</code></li><li>加1后返回新值：<code>int incrementAndGet()</code></li><li>获取当前值：<code>int get()</code></li><li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li></ul><p>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。</p><p><strong>为什么可以通过无锁实现线程安全？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int incrementAndGet(AtomicInteger var)&#123;</span><br><span class="line">    int pre , next;</span><br><span class="line">    do &#123;</span><br><span class="line">        pre = var.get();</span><br><span class="line">        next = pre +1;</span><br><span class="line">    &#125;while (!var.compareAndSet(pre,next));</span><br><span class="line">    return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是AtomicInteger 的incrementAndGet的类似实现方式。<br>通过compareAndSet (<strong>CAS</strong>) 和do while()来实现无锁线程安全。<br>假设我的线程a在执行这个方法时已经获取了pre和next值。那么在dowhile的判断中根据和pre的比较,如果它没有被其他线程的操作改变数值那么就将这个AtomicInteger设置成next。</p><p>而CAS为什么能保证线性安全?<br><code>compareAndSet</code> 确实<strong>没有加锁</strong>，但它是<strong>硬件层面的原子操作</strong> .</p><p>-<br>  <strong>CAS不是加锁</strong>，是硬件原子指令</p><ul><li><strong>并发冲突时只有一个成功</strong>，其他重试</li><li><strong>最终结果正确</strong>：每次调用都会让值增加1</li><li><strong>无锁但线程安全</strong>：通过硬件原子性+重试机制实现</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础（一）</title>
      <link href="/2025/08/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2025/08/06/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>参考来源：<a href="https://liaoxuefeng.com/books/java/threading/index.html">多线程 - Java教程 - 廖雪峰的官方网站</a></p><h2 id="多线程基础："><a href="#多线程基础：" class="headerlink" title="多线程基础："></a>多线程基础：</h2><p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p><p>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p><p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p><h3 id="多进程和多线程的方式比较。"><a href="#多进程和多线程的方式比较。" class="headerlink" title="多进程和多线程的方式比较。"></a>多进程和多线程的方式比较。</h3><p>多进程与多线程比差别在于：</p><ul><li>创建进程开销比线程大。</li><li>进程之间通信比线程要慢，因为线程之间通信可能就是读写同一个变量</li><li>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</li></ul><h2 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h2><ol><li><p>使用extend Thread 重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;my_runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用继承于Runnable 重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;my_runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用Java8 引入的lambda语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">runnableThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;runnableThread1&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>两者的区别：使用runnable可以利用Java多继承的特性。如果原本就有继承就无法继承thread类。推荐使用runnable。<br>Thread也是继承Runnable</p><h2 id="线程的执行流程"><a href="#线程的执行流程" class="headerlink" title="线程的执行流程"></a>线程的执行流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thread run...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;thread end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t.start();</span><br><span class="line">System.out.println(<span class="string">&quot;main end...&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面这段代码的执行流程</p><p>首先main线程启动打印main start<br>接着创建Thread对象。<br>调用Thread.start()启用线程<br>Thread和Main分别继续执行。</p><p>main线程打印 System.out.println(“main end…”);<br>但是t线程还没结束。</p><p>等待t线程执行完毕后t线程就结束了，main（）方法也结束了，主线程就结束了。</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>在java中一个线程对象只能调用一次.start(),当run()方法执行结束后进程就结束了。</p><p>java进程的状态有一下几种</p><ul><li>New：新创建的线程，尚未执行；</li><li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li><li>Waiting：运行中的线程，因为某些操作在等待中；</li><li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li><li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li></ul><p>BLOCKED(排队时)<br>阻塞态：当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态。当该线程持有锁时，该线程将自动变成RUNNABLE状态。</p><p>WAITING(休眠)<br>休眠态：一个线程在等待另一个线程执行一个(唤醒)动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</p><p>TIMED_WAITING (指定休眠时间)<br>指定时间休眠态：基本同WAITING状态，多了个超时参数，调用对应方法时线程将进入TIMED_WAITING状态，这一状态将一直保持到超时期满或者接收到唤醒通知，带有超时参数的常用方法有Thread.sleep、锁对象.wait() 。该状态不同于WAITING,它是可以在指定的时间自行返回的</p><p><strong>当线程启动后，它可以在<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态，线程终止。</strong></p><p>线程终止的原因有：</p><ul><li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li><li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li><li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行线程&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用join方法会让main线程等待直到thread线程结束main线程才会继续往下走</span></span><br></pre></td></tr></table></figure><h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2><p>如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行<code>run()</code>方法，使得自身线程能立刻结束运行。</p><p>基础使用<br>interrupt()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!isInterrupted())&#123;</span><br><span class="line">            n++;</span><br><span class="line">            System.out.flush(); <span class="comment">// 确保立即输出</span></span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自身的线程不断去访问是否被打断的方法isInterrupted()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    thread.interrupt();</span><br><span class="line">    thread.join();</span><br><span class="line">    System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自身线程使用thread.interrupt();就可有打断<br><strong>注意</strong>：自身线程调用thread.interrupt();时不一定会立马打断，他还需要线程执行时isInterrupted()到这里才会结束线程。区别在于是否在阻塞状态。如果在非阻塞的运行状态RUNNABLE，则需要判断isInterrupted()。如果在阻塞状态如join、sleep、wait）会在被中断时抛出InterruptedException。</p><p><strong>另一种线程中断方法</strong></p><p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>HelloThread.running</code>置为<code>false</code>，就可以让线程结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> running= <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(running)&#123;</span><br><span class="line">            System.out.println((n++)+<span class="string">&quot;正在运行...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">MyThread2</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">thread.start();</span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line">thread.running = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a><strong>volatile关键字</strong></h3><p>​此处使用了volatile关键字来定义这个running。<br>​<strong>为什么使用volatile:</strong> 因为在在Java虚拟机中，变量保存在主内存中。各个线程访问主内存会备份一份副本到自己这。所以当各个线程对变量修改时是修改自己副本里的东西，然后再推送给主内存。如果不加volatile关键字那么这个推送的时间是不确定的。</p><p>因此，<code>volatile</code>关键字的目的是告诉虚拟机：</p><ul><li>每次访问变量时，总是获取主内存的最新值；</li><li>每次修改变量后，立刻回写到主内存。</li></ul><p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p><p>如果我们去掉<code>volatile</code>关键字，运行上述程序，发现效果和带<code>volatile</code>差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。</p><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>Java 启动是由jvm启动main线程，main线程里再启动其他线程。当所有线程都结束后jvm退出进程结束。但是如果说有一个线程一直不结束怎么办？</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(LocalTime.now());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个线程正常清况下一但启动就会一直循环。</p><p><strong>那么我们需要关闭jvm怎么办？</strong></p><p>把线程类型分成守护线程类型和非守护线程类型。当非守护线程类型全部执行完毕时不管守护线程有没有执行完毕jvm都会关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">LoopThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoopThread</span>();</span><br><span class="line">        thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Connected to the target VM, address: <span class="string">&#x27;127.0.0.1:60757&#x27;</span>, transport: <span class="string">&#x27;socket&#x27;</span></span><br><span class="line"><span class="number">14</span>:<span class="number">06</span>:<span class="number">13.270548300</span></span><br><span class="line">Disconnected from the target VM, address: <span class="string">&#x27;127.0.0.1:60757&#x27;</span>, transport: <span class="string">&#x27;socket&#x27;</span></span><br></pre></td></tr></table></figure><p>发现连”over”都没输出就结束了<br><strong>因此，JVM退出时，不必关心守护线程是否已结束。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2025/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、创造型模式"><a href="#一、创造型模式" class="headerlink" title="一、创造型模式"></a>一、创造型模式</h1><h2 id="1-工厂方法模式（2025年8月5日）"><a href="#1-工厂方法模式（2025年8月5日）" class="headerlink" title="1.工厂方法模式（2025年8月5日）"></a>1.工厂方法模式（2025年8月5日）</h2><p>工厂方法模式（Factory Method Pattern）,属于创造型模式，旨在统一定义创造对象接口。<br>可以通俗的理解成，在一般情况下不同的东西来源于不同的地方。现在统一了这个地方(factory)，客户只需要根据自身需求去访问这个地方就能获得相对应的东西。其他逻辑无需改变。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>**解耦了对象的创建和使用:**调用方只需要考虑如何使用new出来的对象，不需要考虑他是怎么new出来的全部交给工厂来解决。</li><li><strong>符合开闭原则，易于扩展：</strong> 当需要新加产品时只需要在工厂新加一个对应类和实现方法就行。在用户使用的地方无需修改</li><li><strong>提高了代码的复用性和可维护性:</strong> 创建逻辑全部集中在工厂，避免重复造轮子。维护成本低。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>类的种类增多</strong></li><li><strong>系统变得复杂</strong></li><li><strong>可能会过度设计</strong></li></ul><p>总而言之如果在维护一个后期看起来就会添加许多其他东西可以使用工厂模式，例如手机的支付方式。目前有银行卡，微信，支付宝。未来如果要添加其他的支付方式就可有使用这种设计模式。</p><h2 id="2-参考deepseek给出的支付方式样例"><a href="#2-参考deepseek给出的支付方式样例" class="headerlink" title="2.参考deepseek给出的支付方式样例"></a>2.参考deepseek给出的支付方式样例</h2><p><strong>定义支付接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付接口 - 抽象产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span>;  <span class="comment">// 支付方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">refund</span><span class="params">(<span class="type">double</span> amount)</span>;  <span class="comment">// 退款方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现具体支付方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝支付 - 具体产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Alipay</span> <span class="keyword">implements</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用支付宝支付: &quot;</span> + amount + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">        <span class="comment">// 实际的支付宝支付逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refund</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;支付宝退款: &quot;</span> + amount + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">        <span class="comment">// 实际的支付宝退款逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信支付 - 具体产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatPay</span> <span class="keyword">implements</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用微信支付: &quot;</span> + amount + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">        <span class="comment">// 实际的微信支付逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refund</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;微信退款: &quot;</span> + amount + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">        <span class="comment">// 实际的微信退款逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行卡支付 - 具体产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankCardPay</span> <span class="keyword">implements</span> <span class="title class_">Payment</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用银行卡支付: &quot;</span> + amount + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">        <span class="comment">// 实际的银行卡支付逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refund</span><span class="params">(<span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;银行卡退款: &quot;</span> + amount + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">        <span class="comment">// 实际的银行卡退款逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定义支付工厂接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付工厂接口 - 抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentFactory</span> &#123;</span><br><span class="line">    Payment <span class="title function_">createPayment</span><span class="params">()</span>;  <span class="comment">// 创建支付方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现具体支付工厂</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝支付工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayFactory</span> <span class="keyword">implements</span> <span class="title class_">PaymentFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Payment <span class="title function_">createPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Alipay</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信支付工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WechatPayFactory</span> <span class="keyword">implements</span> <span class="title class_">PaymentFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Payment <span class="title function_">createPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WechatPay</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行卡支付工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankCardPayFactory</span> <span class="keyword">implements</span> <span class="title class_">PaymentFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Payment <span class="title function_">createPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BankCardPay</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟用户选择的支付方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">paymentMethod</span> <span class="operator">=</span> <span class="string">&quot;wechat&quot;</span>; <span class="comment">// 可以从配置或用户输入获取</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据用户选择创建对应的支付工厂</span></span><br><span class="line">        <span class="type">PaymentFactory</span> <span class="variable">factory</span> <span class="operator">=</span> getPaymentFactory(paymentMethod);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用工厂创建支付实例</span></span><br><span class="line">        <span class="type">Payment</span> <span class="variable">payment</span> <span class="operator">=</span> factory.createPayment();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行支付</span></span><br><span class="line">        payment.pay(<span class="number">100.00</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要退款</span></span><br><span class="line">        payment.refund(<span class="number">50.00</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 简单工厂方法，根据类型返回具体工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PaymentFactory <span class="title function_">getPaymentFactory</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type.toLowerCase()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;alipay&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AlipayFactory</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;wechat&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WechatPayFactory</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;bankcard&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BankCardPayFactory</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;不支持的支付方式: &quot;</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体流程</strong></p><p>首先各个产品（支付宝，微信）都要实现对应的payment方法。这是产品的功能。</p><p>从工厂中根据想要的产品去找到对应的factory。每个factory都实现了PaymentFactory。所以可以从PaymentFactory中的Payment方法调用返回对应的产品。</p><h2 id="3-开源框架中的使用"><a href="#3-开源框架中的使用" class="headerlink" title="3.开源框架中的使用"></a>3.开源框架中的使用</h2><p><strong>JDK中的Calendar.getInstance()</strong>: 会根据不同地区，语言环境去返回不同的子类实例。</p><p><strong>spring中的BeanFactory</strong>: 创造bean时会根据不同的类型进行创建。BeanFactory的创建有三种方式：XML配置方式、java方式和注解配置方式。<br><a href="https://blog.csdn.net/weixin_44251099/article/details/130861228">spring 最顶级接口 beanfactory详解-CSDN博客</a></p><h2 id="4-实践"><a href="#4-实践" class="headerlink" title="4.实践"></a>4.实践</h2><p><strong>文件解析模块</strong>：根据上传不同的文件类型chuangj对应的解析器示例和入口</p><p><strong>创建产品抽象类</strong></p><p><img src="/images/pasted-18.png" alt="upload successful"></p><p><strong>创建产品具体</strong></p><p><img src="/images/pasted-19.png" alt="upload successful"></p><p><strong>创建抽象工厂</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    FileProduct <span class="title function_">doFileProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>实现各个工厂</strong></p><p><img src="/images/pasted-20.png" alt="upload successful"></p><p><strong>启动</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileType</span> <span class="operator">=</span> <span class="string">&quot;JSON&quot;</span>;</span><br><span class="line">        <span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> getFactory(fileType);</span><br><span class="line">        <span class="type">FileProduct</span> <span class="variable">fileProduct</span> <span class="operator">=</span> factory.doFileProduct();</span><br><span class="line">        fileProduct.doJieXi();</span><br><span class="line"></span><br><span class="line">        fileType=<span class="string">&quot;Excel&quot;</span>;</span><br><span class="line">        factory=getFactory(fileType);</span><br><span class="line">        fileProduct = factory.doFileProduct();</span><br><span class="line">        fileProduct.doJieXi();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        fileType = <span class="string">&quot;CSV&quot;</span>;</span><br><span class="line">        factory=getFactory(fileType);</span><br><span class="line">        fileProduct = factory.doFileProduct();</span><br><span class="line">        fileProduct.doJieXi();</span><br><span class="line"></span><br><span class="line">        fileType = <span class="string">&quot;XML&quot;</span>;</span><br><span class="line">        factory = getFactory(fileType);</span><br><span class="line">        fileProduct = factory.doFileProduct();</span><br><span class="line">        fileProduct.doJieXi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Factory  <span class="title function_">getFactory</span><span class="params">(String fileType)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fileType.equals(<span class="string">&quot;JSON&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JSONFactoryImpl</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(fileType.equals(<span class="string">&quot;Excel&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExcelFactoryImpl</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(fileType.equals(<span class="string">&quot;CSV&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CSVFactoryImpl</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不支持此类型&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><p><img src="/images/pasted-22.png" alt="upload successful"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工厂方法模式具有的角色和职责：</p><p>抽象产品（Product）：定义产品的公共接口，是所有具体产品的父类。</p><p>具体产品（ConcreteProduct）：实现了抽象产品接口，表示某种具体的产品。</p><p>抽象工厂（Factory）：定义了一个返回产品对象的方法（一般是一个抽象方法）。</p><p>具体工厂（ConcreteFactory）：实现了抽象工厂中的创建产品的方法，生成具体的产品实例。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滴答清单MCP</title>
      <link href="/2025/07/31/%E6%BB%B4%E7%AD%94%E6%B8%85%E5%8D%95MCP/"/>
      <url>/2025/07/31/%E6%BB%B4%E7%AD%94%E6%B8%85%E5%8D%95MCP/</url>
      
        <content type="html"><![CDATA[<h1 id="滴答清单-MCP-服务"><a href="#滴答清单-MCP-服务" class="headerlink" title="滴答清单 MCP 服务"></a>滴答清单 MCP 服务</h1><p>项目地址 <a href="https://github.com/ZH1754629545/dida365-mcp-servers">https://github.com/ZH1754629545/dida365-mcp-servers</a></p><p>这是一个为滴答清单（TickTick&#x2F;Dida365）开发的 Model Context Protocol (MCP) 服务器，使用 TypeScript 编写。该服务允许 AI 助手通过标准化接口与滴答清单 API 进行交互。</p><h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><ul><li>✅ 创建、读取、更新、删除任务</li><li>✅ 管理项目和项目列表</li><li>✅ 支持任务优先级和截止日期</li><li>✅ 通过环境变量安全配置 API Token</li><li>✅ 完整的 TypeScript 类型支持</li><li>✅ 错误处理和API响应验证</li></ul><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="使用MCP-Node版本"><a href="#使用MCP-Node版本" class="headerlink" title="使用MCP (Node版本)"></a>使用MCP (Node版本)</h3><h4 id="DIDA官方获取token"><a href="#DIDA官方获取token" class="headerlink" title="DIDA官方获取token"></a>DIDA官方获取token</h4><p><a href="https://developer.dida365.com/docs/index.html#/openapi?id=get-access-token">OpenAPI - API Doc</a></p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i dida365-mcp-servers</span><br></pre></td></tr></table></figure><h5 id="配置json文件"><a href="#配置json文件" class="headerlink" title="配置json文件"></a>配置json文件</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;dida365&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="comment">//your download path ; example:C:\\nvm4w\\nodejs\\node_modules\\dida365-mcp-servers\\dist</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;DIDA365_TOKEN&quot;</span><span class="punctuation">:</span> your TOKEN</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="使用本地"><a href="#使用本地" class="headerlink" title="使用本地"></a>使用本地</h3><h3 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><h3 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2. 配置环境变量"></a>2. 配置环境变量</h3><p>复制示例环境变量文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> .env.example .<span class="built_in">env</span></span><br></pre></td></tr></table></figure><p>编辑 <code>.env</code> 文件，添加你的滴答清单 API Token：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIDA365_TOKEN=Bearer your_token_here</span><br></pre></td></tr></table></figure><h3 id="3-获取-API-Token"><a href="#3-获取-API-Token" class="headerlink" title="3. 获取 API Token"></a>3. 获取 API Token</h3><ol><li>访问 <a href="https://developer.dida365.com/">滴答清单开放平台</a></li><li>登录你的滴答清单账号</li><li>创建新应用</li><li>获取访问令牌（Access Token）</li><li>将令牌添加到 <code>.env</code> 文件中</li></ol><h3 id="4-构建和运行"><a href="#4-构建和运行" class="headerlink" title="4. 构建和运行"></a>4. 构建和运行</h3><p>开发模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>生产模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><h2 id="可用工具"><a href="#可用工具" class="headerlink" title="可用工具"></a>可用工具</h2><h3 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h3><h4 id="create-task-创建新任务"><a href="#create-task-创建新任务" class="headerlink" title="create_task - 创建新任务"></a><code>create_task</code> - 创建新任务</h4><ul><li><strong>参数</strong>:<ul><li><code>title</code> (string, 必需): 任务标题</li><li><code>projectId</code> (string, 必需): 项目ID</li><li><code>content</code> (string): 任务内容描述</li><li><code>dueDate</code> (string): 截止日期 (ISO 8601格式)</li><li><code>priority</code> (number): 优先级 (0-5)</li></ul></li></ul><h4 id="get-task-by-projectId-and-taskId-通过项目ID和任务ID获取任务"><a href="#get-task-by-projectId-and-taskId-通过项目ID和任务ID获取任务" class="headerlink" title="get_task_by_projectId_and_taskId - 通过项目ID和任务ID获取任务"></a><code>get_task_by_projectId_and_taskId</code> - 通过项目ID和任务ID获取任务</h4><ul><li><strong>参数</strong>:<ul><li><code>projectId</code> (string, 必需): 项目ID</li><li><code>taskId</code> (string, 必需): 任务ID</li></ul></li></ul><h4 id="get-tasks-by-projectId-通过项目ID获取项目中的任务列表"><a href="#get-tasks-by-projectId-通过项目ID获取项目中的任务列表" class="headerlink" title="get_tasks_by_projectId - 通过项目ID获取项目中的任务列表"></a><code>get_tasks_by_projectId</code> - 通过项目ID获取项目中的任务列表</h4><ul><li><strong>参数</strong>:<ul><li><code>projectId</code> (string, 必需): 项目ID</li></ul></li></ul><h4 id="update-task-更新任务"><a href="#update-task-更新任务" class="headerlink" title="update_task - 更新任务"></a><code>update_task</code> - 更新任务</h4><ul><li><strong>参数</strong>:<ul><li><code>taskId</code> (string, 必需): 任务ID</li><li><code>title</code> (string): 任务标题</li><li><code>content</code> (string): 任务内容</li><li><code>dueDate</code> (string): 截止日期</li><li><code>priority</code> (number): 优先级</li><li><code>status</code> (number): 任务状态 (0: 未完成, 1: 已完成)</li></ul></li></ul><h4 id="delete-task-删除任务"><a href="#delete-task-删除任务" class="headerlink" title="delete_task - 删除任务"></a><code>delete_task</code> - 删除任务</h4><ul><li><strong>参数</strong>:<ul><li><code>taskId</code> (string, 必需): 任务ID</li><li><code>projectId</code> (string, 必需): 项目ID</li></ul></li></ul><h4 id="complete-task-完成任务"><a href="#complete-task-完成任务" class="headerlink" title="complete_task - 完成任务"></a><code>complete_task</code> - 完成任务</h4><ul><li><strong>参数</strong>:<ul><li><code>taskId</code> (string, 必需): 任务ID</li><li><code>projectId</code> (string, 必需): 项目ID</li></ul></li></ul><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><h4 id="get-projects-获取项目列表"><a href="#get-projects-获取项目列表" class="headerlink" title="get_projects - 获取项目列表"></a><code>get_projects</code> - 获取项目列表</h4><ul><li><strong>参数</strong>: 无</li></ul><h4 id="get-project-by-projectId-根据项目ID获取项目"><a href="#get-project-by-projectId-根据项目ID获取项目" class="headerlink" title="get_project_by_projectId - 根据项目ID获取项目"></a><code>get_project_by_projectId</code> - 根据项目ID获取项目</h4><ul><li><strong>参数</strong>:<ul><li><code>projectId</code> (string, 必需): 项目ID</li></ul></li></ul><h4 id="create-project-创建新项目"><a href="#create-project-创建新项目" class="headerlink" title="create_project - 创建新项目"></a><code>create_project</code> - 创建新项目</h4><ul><li><strong>参数</strong>:<ul><li><code>name</code> (string, 必需): 项目名称</li><li><code>color</code> (string): 项目颜色, 例如 “#F18181”</li><li><code>sortOrder</code> (integer): 排序值, 默认为0</li><li><code>viewMode</code> (string): 视图模式 (“list”, “kanban”, “timeline”)</li><li><code>kind</code> (string): 项目类型 (“TASK”, “NOTE”)</li></ul></li></ul><h4 id="update-project-by-projectID-根据projectId更新项目"><a href="#update-project-by-projectID-根据projectId更新项目" class="headerlink" title="update_project_by_projectID - 根据projectId更新项目"></a><code>update_project_by_projectID</code> - 根据projectId更新项目</h4><ul><li><strong>参数</strong>:<ul><li><code>projectId</code> (string, 必需): 项目ID</li><li><code>name</code> (string): 项目名称</li><li><code>color</code> (string): 项目颜色</li><li><code>sortOrder</code> (integer): 排序值, 默认为0</li><li><code>viewMode</code> (string): 视图模式 (“list”, “kanban”, “timeline”)</li><li><code>kind</code> (string): 项目类型 (“TASK”, “NOTE”)</li></ul></li></ul><h4 id="update-project-by-projectID-根据projectId删除项目"><a href="#update-project-by-projectID-根据projectId删除项目" class="headerlink" title="update_project_by_projectID - 根据projectId删除项目"></a><code>update_project_by_projectID</code> - 根据projectId删除项目</h4><ul><li><strong>参数</strong>:<ul><li><code>projectId</code> (string, 必需): 项目ID</li></ul></li></ul><h2 id="可用资源"><a href="#可用资源" class="headerlink" title="可用资源"></a>可用资源</h2><h3 id="dida365-tasks"><a href="#dida365-tasks" class="headerlink" title="dida365://tasks"></a><code>dida365://tasks</code></h3><p>获取所有任务的JSON格式概览</p><h3 id="dida365-projects"><a href="#dida365-projects" class="headerlink" title="dida365://projects"></a><code>dida365://projects</code></h3><p>获取所有项目的JSON格式概览</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── src/</span><br><span class="line">│   └── index.ts          # 主服务器文件</span><br><span class="line">├── dist/                 # 编译输出目录</span><br><span class="line">├── .env.example          # 环境变量示例</span><br><span class="line">├── package.json          # 项目配置</span><br><span class="line">├── tsconfig.json        # TypeScript 配置</span><br><span class="line">└── README.md            # 项目文档</span><br></pre></td></tr></table></figure><h2 id="API-接口说明"><a href="#API-接口说明" class="headerlink" title="API 接口说明"></a>API 接口说明</h2><p>本服务使用滴答清单官方 API：</p><ul><li>基础URL: <code>https://api.dida365.com/open/v1</code></li><li>认证方式: Bearer Token</li><li>请求格式: JSON</li><li>官方文档: <a href="https://developer.dida365.com/api#/openap">https://developer.dida365.com/api#/openap</a></li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>服务包含完整的错误处理机制：</p><ul><li>API 调用失败时返回详细错误信息</li><li>网络错误和超时处理</li><li>参数验证和类型检查</li><li>Token 验证</li></ul><h2 id="开发说明"><a href="#开发说明" class="headerlink" title="开发说明"></a>开发说明</h2><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>欢迎提交 Issue 和 Pull Request！</p>]]></content>
      
      
      <categories>
          
          <category> MCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring AI 初步开发</title>
      <link href="/2025/07/15/spring-AI-%E5%88%9D%E6%AD%A5%E5%BC%80%E5%8F%91/"/>
      <url>/2025/07/15/spring-AI-%E5%88%9D%E6%AD%A5%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-AI-初步开发"><a href="#spring-AI-初步开发" class="headerlink" title="spring AI 初步开发"></a>spring AI 初步开发</h1><h3 id="官方文档-Spring-AI"><a href="#官方文档-Spring-AI" class="headerlink" title="官方文档:Spring AI"></a>官方文档:<a href="https://spring.io/projects/spring-ai">Spring AI</a></h3><p>spring AI 极大的简化了对AI的prompt工程。可以区分为用户(user)，系统(system),助手(assistant) 三个模块。以及Advisor（拦截器）、Tool（工具）、RAG(检索增强) 、MCP(模型上下文协议)等。</p><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目:"></a>初始化项目:</h3><p>​官方文档：<a href="https://springdoc.cn/spring-ai/getting-started.html">入门 :: Spring AI 中文文档</a><br>​注: java版本17以上，这里选择21<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-ai-bom&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span><span class="number">.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        deepseek 模型--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-ai-starter-model-deepseek&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-ai-advisors-vector-store&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;kryo&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.6</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: MyAI</span><br><span class="line">  ai:</span><br><span class="line">    deepseek:</span><br><span class="line">      api-key: xxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">      base-url: https:<span class="comment">//api.deepseek.com/v1</span></span><br><span class="line">      chat:</span><br><span class="line">        options:</span><br><span class="line">          model: deepseek-chat</span><br></pre></td></tr></table></figure><p>因为deepseek不支持检索增强所以换了springboot alibaba 的dashscope模型。</p><p>一下是springboot alibaba配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;spring-milestones&lt;/id&gt;</span><br><span class="line">        &lt;name&gt;Spring Milestones&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;https:<span class="comment">//repo.spring.io/milestone&lt;/url&gt;</span></span><br><span class="line">        &lt;snapshots&gt;</span><br><span class="line">            &lt;enabled&gt;<span class="literal">false</span>&lt;/enabled&gt;</span><br><span class="line">        &lt;/snapshots&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line"></span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;aliyunmaven&lt;/id&gt;</span><br><span class="line">        &lt;name&gt;aliyun&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;https:<span class="comment">//maven.aliyun.com/repository/public&lt;/url&gt;</span></span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud.ai&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-ai-alibaba-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span><span class="number">.0</span>-M6<span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;kryo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.6</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-ai-markdown-document-reader&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span><span class="number">.0</span>-M6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-ai-mcp-client-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span><span class="number">.0</span>-M6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: AIFaster</span><br><span class="line">  ai:</span><br><span class="line">    dashscope:</span><br><span class="line">      api-key: xxxxxxxxxxxxxxxxxxxx</span><br><span class="line">      chat:</span><br><span class="line">       options:</span><br><span class="line">         model: deepseek-v3</span><br><span class="line">    mcp:</span><br><span class="line">      client:</span><br><span class="line">        enabled: <span class="literal">true</span></span><br><span class="line">        name: mcp-client</span><br><span class="line">        version: <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">        type: SYNC</span><br><span class="line">        request-timeout: <span class="number">60000</span></span><br><span class="line">        stdio:</span><br><span class="line">          servers-configuration: classpath:/mcp-servers.json</span><br></pre></td></tr></table></figure><h3 id="chatModel-和-chatClient"><a href="#chatModel-和-chatClient" class="headerlink" title="chatModel 和 chatClient"></a>chatModel 和 chatClient</h3><blockquote><h4 id="Spring-AI-中的-ChatModel-和-ChatClient"><a href="#Spring-AI-中的-ChatModel-和-ChatClient" class="headerlink" title="Spring AI 中的 ChatModel 和 ChatClient"></a>Spring AI 中的 ChatModel 和 ChatClient</h4><p>在 Spring AI 框架中，<code>ChatModel</code> 和 <code>ChatClient</code> 是与 AI 聊天功能相关的两个重要接口，它们有不同的职责和使用场景。</p><h5 id="ChatModel"><a href="#ChatModel" class="headerlink" title="ChatModel"></a>ChatModel</h5><p><code>ChatModel</code> 是 Spring AI 中用于与 AI 模型交互的核心接口，主要特点包括：</p><ol><li><strong>功能定位</strong>：<ul><li>提供与底层 AI 模型(如 OpenAI、Anthropic 等)的直接交互能力</li><li>支持完整的聊天对话功能，包括多轮对话、系统提示等</li></ul></li><li><strong>主要方法</strong>：<ul><li><code>generate()</code> - 生成聊天响应</li><li><code>generate(Prompt)</code> - 根据提示生成响应</li><li>支持流式和非流式响应</li></ul></li><li><strong>使用场景</strong>：<ul><li>需要精细控制 AI 模型交互时</li><li>需要访问底层模型的高级功能时</li><li>需要直接处理 Prompt 和 Response 对象时</li></ul></li></ol><h5 id="ChatClient"><a href="#ChatClient" class="headerlink" title="ChatClient"></a>ChatClient</h5><p><code>ChatClient</code> 是一个更高级别的抽象接口，主要特点包括：</p><ol><li><strong>功能定位</strong>：<ul><li>提供更简单的 API 用于聊天交互</li><li>隐藏了部分底层复杂性，更适合简单场景</li></ul></li><li><strong>主要方法</strong>：<ul><li><code>call(String message)</code> - 发送消息并获取响应</li><li>通常返回简单的字符串响应</li></ul></li><li><strong>使用场景</strong>：<ul><li>快速实现简单的聊天功能</li><li>不需要复杂配置或高级功能时</li><li>希望简化代码时</li></ul></li></ol></blockquote><p>​–deepseek</p><p>简单来说使用chatModel是直接对AI接口发起请求的角色,而chatClient可以在这之前和之后添加很多方便快捷的操作。<br>直接用chatModel发起请求:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/simple/chat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">simpleChat</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dashScopeChatModel.call(<span class="keyword">new</span> <span class="title class_">Prompt</span>(DEFAULT_PROMPT)).getResult().getOutput().getText();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置chatClient发送请求:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ChatClient chatClient;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChatModel dashScopeChatModel;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DashScopeChatModelImpl</span><span class="params">(ChatModel chatModel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dashScopeChatModel = chatModel;</span><br><span class="line">        <span class="built_in">this</span>.chatClient = ChatClient.builder(<span class="built_in">this</span>.dashScopeChatModel)</span><br><span class="line">                .defaultSystem(<span class="keyword">new</span> <span class="title class_">SimplePrompt</span>().getDefaultPrompt()) <span class="comment">//默认系统消息</span></span><br><span class="line">                .defaultAdvisors(</span><br><span class="line">                <span class="comment">//配置拦截器，比如消息存储，日志拦截等。</span></span><br><span class="line">                )</span><br><span class="line">            <span class="comment">//还可以配置其他许多默认</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">generate</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="type">SimpleResponse</span> <span class="variable">simpleResponse</span> <span class="operator">=</span> chatClient.prompt().advisors(advisor-&gt;advisor.param(CHAT_MEMORY_CONVERSATION_ID_KEY,<span class="string">&quot;002&quot;</span>).param(CHAT_MEMORY_RETRIEVE_SIZE_KEY,<span class="number">100</span>)).advisors(<span class="keyword">new</span> <span class="title class_">QuestionAnswerAdvisor</span>(vectorStore)).tools(toolCallbackProvider).user(message).call().entity(SimpleResponse.class); <span class="comment">//使用entity直接转换成对应类型</span></span><br><span class="line">        <span class="keyword">return</span> simpleResponse.toString();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//流式响应</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;ChatResponse&gt; <span class="title function_">generateStream</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        Flux&lt;ChatResponse&gt; streamWithMetaData = chatClient.prompt().advisors(advisorSpec -&gt; advisorSpec.param(CHAT_MEMORY_CONVERSATION_ID_KEY,<span class="string">&quot;678&quot;</span>).param(CHAT_MEMORY_RETRIEVE_SIZE_KEY,<span class="number">10</span>)).user(message).stream().chatResponse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> streamWithMetaData;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>######################</p><h3 id="系统-System-、用户-user"><a href="#系统-System-、用户-user" class="headerlink" title="系统(System)、用户(user)"></a>系统(System)、用户(user)</h3><p>系统相当于出了用户发送的内容外你希望这个模块做到什么功能。比如医疗系统的AI就可以在系统那里写上。你是一名资深的医生…..。 用户就是用户发送的内容。</p><h3 id="上下文连续对话-chatMemory"><a href="#上下文连续对话-chatMemory" class="headerlink" title="上下文连续对话(chatMemory)"></a>上下文连续对话(chatMemory)</h3><p><a href="https://springdoc.cn/spring-ai/api/chat-memory.html">聊天记忆 :: Spring AI 中文文档</a></p><p>基于内存可以使用 InMemoryChatMemoryRepository();<br>这里使用了kryo去保存和读取上下文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="type">String</span> <span class="variable">fileDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>)+<span class="string">&quot;/chat-memery&quot;</span>;</span><br><span class="line">  <span class="type">ChatMemory</span> <span class="variable">chatMemory</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">FileBasedChatMemory</span>(fileDir);</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DashScopeChatModelImpl</span><span class="params">(ChatModel chatModel)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.chatClient = ChatClient.builder(<span class="built_in">this</span>.dashScopeChatModel)</span><br><span class="line">              .defaultSystem(<span class="keyword">new</span> <span class="title class_">SimplePrompt</span>().getDefaultPrompt())</span><br><span class="line">              .defaultAdvisors(</span><br><span class="line">                  <span class="keyword">new</span> <span class="title class_">MessageChatMemoryAdvisor</span>(chatMemory),</span><br><span class="line">              )</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过参考InMemoryChatMemoryRepository()基于内存的实现方法去实现FileBasedChatMemory</p><h3 id="流式响应Flux"><a href="#流式响应Flux" class="headerlink" title="流式响应Flux"></a>流式响应Flux</h3><p><a href="https://www.cnblogs.com/crazymakercircle/p/16127013.html">Flux 和 Mono 、reactor实战 （史上最全） - 技术自由圈 - 博客园</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> Flux&lt;ChatResponse&gt; <span class="title function_">generateStream</span><span class="params">(String message)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Flux&lt;ChatResponse&gt; streamWithMetaData = chatClient.prompt().advisors(advisorSpec -&gt; advisorSpec.param(ChatMemory.CONVERSATION_ID,<span class="string">&quot;678&quot;</span>)).user(message).stream().chatResponse().doOnNext(chatResponse -&gt; &#123;</span><br><span class="line">            <span class="type">AssistantMessage</span> <span class="variable">assistantMessage</span> <span class="operator">=</span> chatResponse.getResult().getOutput();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> assistantMessage.getText();</span><br><span class="line">                    log.info(text);</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        streamWithMetaData</span></span><br><span class="line"><span class="comment">//                .doOnNext(chatResponse -&gt; &#123;</span></span><br><span class="line"><span class="comment">//                    AssistantMessage assistantMessage = chatResponse.getResult().getOutput();</span></span><br><span class="line"><span class="comment">//                    String text = assistantMessage.getText();</span></span><br><span class="line"><span class="comment">//                    log.info(text);</span></span><br><span class="line"><span class="comment">//                &#125;)</span></span><br><span class="line"><span class="comment">//                .doOnError(error -&gt; System.err.println(&quot;error: &quot; + error.getMessage()))</span></span><br><span class="line"><span class="comment">//                .doOnComplete(() -&gt; System.out.println(&quot;\n&gt;&gt;&gt; over&quot;))</span></span><br><span class="line"><span class="comment">//                .blockLast();</span></span><br><span class="line">        log.info(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> streamWithMetaData;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>利用doOnNext取获取信息。<br>这里有3个概念，发布者，订阅者，订阅。感觉有点类似与消息队列那种，只有有订阅者(消费者)订阅 publisher才有用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileBasedChatMemory</span> <span class="keyword">implements</span> <span class="title class_">ChatMemory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String BASE_DIR;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        kryo.setRegistrationRequired(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 设置实例化策略</span></span><br><span class="line">        kryo.setInstantiatorStrategy(<span class="keyword">new</span> <span class="title class_">StdInstantiatorStrategy</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造对象时，指定文件保存目录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileBasedChatMemory</span><span class="params">(String dir)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.BASE_DIR = dir;</span><br><span class="line">        <span class="type">File</span> <span class="variable">baseDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dir);</span><br><span class="line">        <span class="keyword">if</span> (!baseDir.exists()) &#123;</span><br><span class="line">            baseDir.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String conversationId, Message message)</span> &#123;</span><br><span class="line">        ChatMemory.<span class="built_in">super</span>.add(conversationId, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String conversationId, List&lt;Message&gt; messages)</span> &#123;</span><br><span class="line">        List&lt;Message&gt; conversationMessages = getOrCreateConversation(conversationId);</span><br><span class="line">        conversationMessages.addAll(messages);</span><br><span class="line">        saveConversation(conversationId, conversationMessages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Message&gt; <span class="title function_">get</span><span class="params">(String conversationId, <span class="type">int</span> lastN)</span> &#123;</span><br><span class="line">        List&lt;Message&gt; allMessages = getOrCreateConversation(conversationId);</span><br><span class="line">        <span class="keyword">return</span> allMessages.stream()</span><br><span class="line">                .skip(Math.max(<span class="number">0</span>, allMessages.size()-lastN))</span><br><span class="line">                .toList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">(String conversationId)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> getConversationFile(conversationId);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Message&gt; <span class="title function_">getOrCreateConversation</span><span class="params">(String conversationId)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> getConversationFile(conversationId);</span><br><span class="line">        List&lt;Message&gt; messages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file))) &#123;</span><br><span class="line">                messages = kryo.readObject(input, ArrayList.class);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveConversation</span><span class="params">(String conversationId, List&lt;Message&gt; messages)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> getConversationFile(conversationId);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file))) &#123;</span><br><span class="line">            kryo.writeObject(output, messages);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> File <span class="title function_">getConversationFile</span><span class="params">(String conversationId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">File</span>(BASE_DIR, conversationId + <span class="string">&quot;.kryo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后在chatClient发送请求时添加对应的上下文记忆大小，对话id等即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chatClient.prompt().advisors(advisor-&gt;advisor.param(CHAT_MEMORY_CONVERSATION_ID_KEY,<span class="string">&quot;002&quot;</span>).param(CHAT_MEMORY_RETRIEVE_SIZE_KEY,<span class="number">100</span>))</span><br></pre></td></tr></table></figure><h3 id="Advisor（拦截器）"><a href="#Advisor（拦截器）" class="headerlink" title="Advisor（拦截器）"></a>Advisor（拦截器）</h3><p><a href="https://springdoc.cn/spring-ai/api/advisors.html">Advisor API :: Spring AI 中文文档</a></p><p>用于在发起请求前后做的操作。</p><h4 id="日志拦截器-用于日志输出发送和返回的propt和response"><a href="#日志拦截器-用于日志输出发送和返回的propt和response" class="headerlink" title="日志拦截器(用于日志输出发送和返回的propt和response)"></a>日志拦截器(用于日志输出发送和返回的propt和response)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.chatClient = ChatClient.builder(<span class="built_in">this</span>.dashScopeChatModel)</span><br><span class="line">        .defaultSystem(<span class="keyword">new</span> <span class="title class_">SimplePrompt</span>().getDefaultPrompt())</span><br><span class="line">        .defaultAdvisors(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MyLoggerAdvisor</span>()</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>​</p><p>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLoggerAdvisor</span> <span class="keyword">implements</span> <span class="title class_">CallAroundAdvisor</span>, StreamAroundAdvisor &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AdvisedResponse <span class="title function_">aroundCall</span><span class="params">(AdvisedRequest advisedRequest, CallAroundAdvisorChain chain)</span> &#123;</span><br><span class="line">        advisedRequest = <span class="built_in">this</span>.before(advisedRequest);</span><br><span class="line">        <span class="type">AdvisedResponse</span> <span class="variable">advisedResponse</span> <span class="operator">=</span> chain.nextAroundCall(advisedRequest);</span><br><span class="line">        <span class="built_in">this</span>.observeAfter(advisedResponse);</span><br><span class="line">        <span class="keyword">return</span> advisedResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;AdvisedResponse&gt; <span class="title function_">aroundStream</span><span class="params">(AdvisedRequest advisedRequest, StreamAroundAdvisorChain chain)</span> &#123;</span><br><span class="line">        advisedRequest = <span class="built_in">this</span>.before(advisedRequest);</span><br><span class="line">        Flux&lt;AdvisedResponse&gt; advisedResponses = chain.nextAroundStream(advisedRequest);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">MessageAggregator</span>()).aggregateAdvisedResponse(advisedResponses,<span class="built_in">this</span>::observeAfter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> AdvisedRequest <span class="title function_">before</span><span class="params">(AdvisedRequest request)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;AI Request: &#123;&#125;&quot;</span>, request.adviseContext());</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">observeAfter</span><span class="params">(AdvisedResponse advisedResponse)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;AI Response: &#123;&#125;&quot;</span>, advisedResponse.response().getResult().getOutput().getText());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RAG（检索增强）"><a href="#RAG（检索增强）" class="headerlink" title="RAG（检索增强）"></a>RAG（检索增强）</h3><p><a href="https://springdoc.cn/spring-ai/api/retrieval-augmented-generation.html">检索增强生成 :: Spring AI 中文文档</a></p><p>通过向量存储知识库用来快速匹配到对应内容然后发送给AI。（利用向量的数学方法在空间上快速匹配，离得越近匹配度越高）。<br>这里使用md作为知识库数据<br>引入springai md 读取依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-ai-markdown-document-reader&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span><span class="number">.0</span>-M6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置vector 向量存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    MyMarkdownReader myMarkdownReader;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> VectorStore <span class="title function_">vectorStore</span><span class="params">(EmbeddingModel embeddingModel)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">SimpleVectorStore</span> <span class="variable">simpleVectorStore</span> <span class="operator">=</span> SimpleVectorStore.builder(embeddingModel).build();</span><br><span class="line">        List&lt;Document&gt;markDownDocs =  myMarkdownReader.loadMarkdown(); <span class="comment">//读取本地文件</span></span><br><span class="line">        simpleVectorStore.add(markDownDocs);</span><br><span class="line">        <span class="keyword">return</span> simpleVectorStore;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取本地md文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMarkdownReader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourcePatternResolver resourcePatternResolver;</span><br><span class="line"></span><br><span class="line">    MyMarkdownReader(ResourcePatternResolver resourcePatternResolver)&#123;</span><br><span class="line">        <span class="built_in">this</span>.resourcePatternResolver= resourcePatternResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Document&gt; <span class="title function_">loadMarkdown</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Document&gt; allDocs= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Resource[] resources = resourcePatternResolver.getResources(<span class="string">&quot;classpath:doc/*.md&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> resource.getFilename();</span><br><span class="line">                <span class="type">MarkdownDocumentReaderConfig</span> <span class="variable">config</span> <span class="operator">=</span> MarkdownDocumentReaderConfig.builder()</span><br><span class="line">                        .withHorizontalRuleCreateDocument(<span class="literal">true</span>)</span><br><span class="line">                        .withIncludeCodeBlock(<span class="literal">false</span>)</span><br><span class="line">                        .withIncludeBlockquote(<span class="literal">false</span>)</span><br><span class="line">                        .withAdditionalMetadata(<span class="string">&quot;filename&quot;</span>, fileName)</span><br><span class="line">                        .build();</span><br><span class="line">                <span class="type">MarkdownDocumentReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MarkdownDocumentReader</span>(resource, config);</span><br><span class="line">                allDocs.addAll(reader.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;加载markdown 文件失败&quot;</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allDocs;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时在拦截器advisor里添加QuestionAnswerAdvisor即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> VectorStore vectorStore;</span><br><span class="line">        <span class="type">SimpleResponse</span> <span class="variable">simpleResponse</span> <span class="operator">=</span> chatClient.prompt().advisors(<span class="keyword">new</span> <span class="title class_">QuestionAnswerAdvisor</span>(vectorStore)).user(message).call().entity(SimpleResponse.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里的QuestionAnswerAdvisor()可能是老的继承导致没有作用新的implements BaseAdvisor --2025年7月26日</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h3><p><a href="https://springdoc.cn/spring-ai/api/mcp/mcp-overview.html">模型上下文协议（MCP） :: Spring AI 中文文档</a></p><p>使用MCP就可以调用其他人基于MCP协议提供的服务.这里就是简单的使用MCP去调用高德地图提供的MCP。</p><p>首先得去高德地图获取key。<a href="https://lbs.amap.com/?ref=https://console.amap.com/dev/flow/manage">高德开放平台 | 高德地图API</a></p><p>引入依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-ai-mcp-client-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span><span class="number">.0</span>-M6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>修改yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: AIFaster</span><br><span class="line">  ai:</span><br><span class="line">    dashscope:</span><br><span class="line">      api-key: xxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">      chat:</span><br><span class="line">       options:</span><br><span class="line">         model: deepseek-v3</span><br><span class="line">    mcp:</span><br><span class="line">      client:</span><br><span class="line">        enabled: true</span><br><span class="line">        name: mcp-client</span><br><span class="line">        version: 1.0.0</span><br><span class="line">        type: SYNC</span><br><span class="line">        request-timeout: 60000</span><br><span class="line">        stdio:</span><br><span class="line">          servers-configuration: classpath:/mcp-servers.json</span><br></pre></td></tr></table></figure><p>servers-configuration 里 存放对应key的配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;amap-maps&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx.cmd&quot;</span><span class="punctuation">,</span>  <span class="comment">//windows得加.cmd 其他不用</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-y&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;@amap/amap-maps-mcp-server&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;AMAP_MAPS_API_KEY&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> ToolCallbackProvider toolCallbackProvider;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateMcp</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> chatClient.prompt().advisors(advisor-&gt;advisor.param(CHAT_MEMORY_CONVERSATION_ID_KEY,<span class="string">&quot;003&quot;</span>).param(CHAT_MEMORY_RETRIEVE_SIZE_KEY,<span class="number">100</span>)).tools(toolCallbackProvider).user(message).call().content();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="/images/pasted-9.png" alt="upload successful"></p><h3 id="Tool（工具）"><a href="#Tool（工具）" class="headerlink" title="Tool（工具）"></a>Tool（工具）</h3><p><a href="https://docs.spring.io/spring-ai/reference/1.1-SNAPSHOT/api/tools.html#_quick_start">Tool Calling :: Spring AI Reference</a></p><p>除了MCP提供的工具以外也可以自己写工具。<br>&#x2F;&#x2F;TODO</p>]]></content>
      
      
      <categories>
          
          <category> spring AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring AI </tag>
            
            <tag> MCP </tag>
            
            <tag> advisor </tag>
            
            <tag> 向量存储 </tag>
            
            <tag> RAG </tag>
            
            <tag> AI连续对话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能BI项目 (完结？) RabbitMq 消息队列</title>
      <link href="/2025/07/14/%E6%99%BA%E8%83%BDBI%E9%A1%B9%E7%9B%AE-%E5%AE%8C%E7%BB%93%EF%BC%9F-RabbitMq-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2025/07/14/%E6%99%BA%E8%83%BDBI%E9%A1%B9%E7%9B%AE-%E5%AE%8C%E7%BB%93%EF%BC%9F-RabbitMq-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p> 最后主要是做了一个利用RabbitMq 去发布和接收生成图表的任务的工作。</p><p> Q:为什么要用RabbitMq ？用线程池不是已经解决了吗<br> A:在单机开发中线程池 确实能解决一些问题，但是到分布式环境中，使用消息队列可以更加方便的进行开发。因为消息队列可以算是一个跨系统的东西。可以很好的解耦合。而且线程池无法解决优先顺序问题。</p><p><a href="https://juejin.cn/post/7225474899480526885">为什么说前端监控系统离不开 RabbitMQ？前端监控系统是采集用户端的异常、性能、业务埋点等数据上报，在服务端做存储， - 掘金</a></p><h2 id="消息队列："><a href="#消息队列：" class="headerlink" title="消息队列："></a>消息队列：</h2><p>​    我认为的消息队列它拥有可持久化，顺序化，有容错等，有很多方便的工具的东西。</p><h3 id="持久化："><a href="#持久化：" class="headerlink" title="持久化："></a>持久化：</h3><p>​    它可以把数据保存起来，即使重启也没事。并不像缓存那样。</p><h3 id="容错机制："><a href="#容错机制：" class="headerlink" title="容错机制："></a>容错机制：</h3><p>​    他有一个死信队列的东西，专门用来解决如果出错了要怎么处理的方案。</p><h3 id="分配机制："><a href="#分配机制：" class="headerlink" title="分配机制："></a>分配机制：</h3><p>​    rabbitMq 有一个类似与计算机网络交换机，可以根据不同的routingKey（IP地址）去发送生产者的需求给目标消费者的消息队列。</p><h3 id="消息确认机制："><a href="#消息确认机制：" class="headerlink" title="消息确认机制："></a>消息确认机制：</h3><p>​    当消费者接收消息后，可以返回消息(ack、nack、reject） 来告诉消息队列，然后进行相对应的处理。</p><h2 id="实现BI项目消息队列："><a href="#实现BI项目消息队列：" class="headerlink" title="实现BI项目消息队列："></a>实现BI项目消息队列：</h2><p><strong>初始化新的Bi队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.springbootinit.bizmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.yupi.springbootinit.constant.BiMqConstant;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于创建测试程序用到的交换机和队列（只用在程序启动前执行一次）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiInitMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建连接工厂</span></span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建连接</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">            <span class="comment">// 创建通道</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">            <span class="comment">// 定义交换机的名称为&quot;code_exchange&quot;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> BiMqConstant.BI_EXCHANGE_NAME;</span><br><span class="line">            <span class="comment">// 声明交换机，指定交换机类型为 direct</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建队列，随机分配一个队列名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> BiMqConstant.BI_QUEUE_NAME;</span><br><span class="line">            <span class="comment">// 声明队列，设置队列持久化、非独占、非自动删除，并传入额外的参数为 null</span></span><br><span class="line">            channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 将队列绑定到交换机，指定路由键为 &quot;my_routingKey&quot;</span></span><br><span class="line">            channel.queueBind(queueName, EXCHANGE_NAME, BiMqConstant.BI_ROUTING_KEY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>生产者</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.springbootinit.bizmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用@Component注解标记该类为一个组件，让Spring框架能够扫描并将其纳入管理</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiMessageProducer</span> &#123;</span><br><span class="line"><span class="comment">// 使用@Resource注解对rabbitTemplate进行依赖注入</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange   交换机名称，指定消息要发送到哪个交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey 路由键，指定消息要根据什么规则路由到相应的队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message    消息内容，要发送的具体消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String exchange, String routingKey, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用rabbitTemplate的convertAndSend方法将消息发送到指定的交换机和路由键</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>消费者</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.springbootinit.bizmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.yupi.springbootinit.common.ErrorCode;</span><br><span class="line"><span class="keyword">import</span> com.yupi.springbootinit.constant.BiMqConstant;</span><br><span class="line"><span class="keyword">import</span> com.yupi.springbootinit.exception.BusinessException;</span><br><span class="line"><span class="keyword">import</span> com.yupi.springbootinit.exception.ThrowUtils;</span><br><span class="line"><span class="keyword">import</span> com.yupi.springbootinit.mapper.ChartMapper;</span><br><span class="line"><span class="keyword">import</span> com.yupi.springbootinit.model.entity.Chart;</span><br><span class="line"><span class="keyword">import</span> com.yupi.springbootinit.service.ChartService;</span><br><span class="line"><span class="keyword">import</span> com.yupi.springbootinit.service.DeepSeekService;</span><br><span class="line"><span class="keyword">import</span> com.yupi.springbootinit.utils.ExcelUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.AmqpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.handler.annotation.Header;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用@Component注解标记该类为一个组件，让Spring框架能够扫描并将其纳入管理</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 使用@Slf4j注解生成日志记录器</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiMessageConsumer</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    ChartService chartService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    DeepSeekService deepSeekService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收消息的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message      接收到的消息内容，是一个字符串类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel      消息所在的通道，可以通过该通道与 RabbitMQ 进行交互，例如手动确认消息、拒绝消息等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> deliveryTag  消息的投递标签，用于唯一标识一条消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 使用@SneakyThrows注解简化异常处理</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="comment">// 使用@RabbitListener注解指定要监听的队列名称为&quot;code_queue&quot;，并设置消息的确认机制为手动确认</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &#123;BiMqConstant.BI_QUEUE_NAME&#125;, ackMode = &quot;MANUAL&quot;)</span></span><br><span class="line">    <span class="comment">// @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag是一个方法参数注解,用于从消息头中获取投递标签(deliveryTag),</span></span><br><span class="line">    <span class="comment">// 在RabbitMQ中,每条消息都会被分配一个唯一的投递标签，用于标识该消息在通道中的投递状态和顺序。通过使用@Header(AmqpHeaders.DELIVERY_TAG)注解,可以从消息头中提取出该投递标签,并将其赋值给long deliveryTag参数。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(String message, Channel channel, <span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="type">long</span> deliveryTag)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用日志记录器打印接收到的消息内容</span></span><br><span class="line">        log.info(<span class="string">&quot;receiveMessage message = &#123;&#125;&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果为空消息</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(message))&#123;</span><br><span class="line">            channel.basicNack(deliveryTag,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.NOT_FOUND_ERROR,<span class="string">&quot;图表为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取图表</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">chartId</span> <span class="operator">=</span> Long.parseLong(message);</span><br><span class="line">        <span class="type">Chart</span> <span class="variable">chart</span> <span class="operator">=</span> chartService.getById(chartId);</span><br><span class="line"></span><br><span class="line">        ThrowUtils.throwIf(chart==<span class="literal">null</span>,ErrorCode.PARAMS_ERROR,<span class="string">&quot;图表为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行AiChart</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> doAiChart(chart);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">            channel.basicNack(deliveryTag,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR,<span class="string">&quot;执行AiChart失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;执行AiChart成功&quot;</span>);</span><br><span class="line">        <span class="comment">// 投递标签是一个数字标识,它在消息消费者接收到消息后用于向RabbitMQ确认消息的处理状态。通过将投递标签传递给channel.basicAck(deliveryTag, false)方法,可以告知RabbitMQ该消息已经成功处理,可以进行确认和从队列中删除。</span></span><br><span class="line">        <span class="comment">// 手动确认消息的接收，向RabbitMQ发送确认消息</span></span><br><span class="line">        channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doAiChart</span><span class="params">(Chart chart)</span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//先根据chartId获取图表数据</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">csvData</span> <span class="operator">=</span> chartService.getChartDataByChartId(chart.getId());</span><br><span class="line">           <span class="comment">//处理没有数据情况</span></span><br><span class="line">           ThrowUtils.throwIf(StringUtils.isBlank(csvData),ErrorCode.NOT_FOUND_ERROR,<span class="string">&quot;图表数据找不到&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//更新chart</span></span><br><span class="line">           <span class="type">Chart</span> <span class="variable">updateChart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chart</span>();</span><br><span class="line">           updateChart.setId(chart.getId());</span><br><span class="line">           <span class="comment">//设置正在执行状态</span></span><br><span class="line">           updateChart.setStatus(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">runningUpdate</span> <span class="operator">=</span> chartService.updateById(updateChart);</span><br><span class="line">           ThrowUtils.throwIf(!runningUpdate,ErrorCode.SYSTEM_ERROR,<span class="string">&quot;更新状态running失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//用户输入题词器</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">goal</span> <span class="operator">=</span> chart.getGoal();</span><br><span class="line">           <span class="type">String</span> <span class="variable">chartType</span> <span class="operator">=</span> chart.getChartType();</span><br><span class="line"></span><br><span class="line">           <span class="type">String</span> <span class="variable">userInput</span> <span class="operator">=</span> chartService.getUserInput(goal,chartType,csvData);</span><br><span class="line">           <span class="comment">//发起请求</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> deepSeekService.callDeepSeek(userInput);</span><br><span class="line"></span><br><span class="line">           String[] split = result.split(<span class="string">&quot;【【【【【&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span>(split.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">               chartService.handleChartUpdateError(chart.getId(),<span class="string">&quot;AI 生成错误&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">String</span> <span class="variable">genChart</span> <span class="operator">=</span> split[<span class="number">1</span>].trim();</span><br><span class="line">           <span class="type">String</span> <span class="variable">genResult</span> <span class="operator">=</span> split[<span class="number">2</span>].trim();</span><br><span class="line">           <span class="comment">//得到结果后，再更新一次</span></span><br><span class="line">           <span class="type">Chart</span> <span class="variable">updateChartResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chart</span>();</span><br><span class="line">           updateChartResult.setId(chart.getId());</span><br><span class="line">           updateChartResult.setStatus(<span class="string">&quot;succeed&quot;</span>);</span><br><span class="line">           updateChartResult.setGenChart(genChart);</span><br><span class="line">           updateChartResult.setGenResult(genResult);</span><br><span class="line"></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">updateResult</span> <span class="operator">=</span> chartService.updateById(updateChartResult);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(!updateResult)&#123;</span><br><span class="line">              chartService.handleChartUpdateError(chart.getId(),<span class="string">&quot;更新图表成功状态失败&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 此时只需要将上次做的异步创建中的线程池改成生产者发送需求进入消息队列，然后让消费者去按顺序执行任务即可。</p><p><strong>RabbitMq 有很多不同类型的交换机一个一个说太麻烦了，不如直接贴一个官方教程。以后忘了再看。</strong><br> <a href="https://www.rabbitmq.com/tutorials/tutorial-four-java">RabbitMQ tutorial - Routing | RabbitMQ</a></p>]]></content>
      
      
      <categories>
          
          <category> 智能BI项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMq </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能BI项目（五）线程池和队列</title>
      <link href="/2025/07/14/%E6%99%BA%E8%83%BDBI%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%94%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2025/07/14/%E6%99%BA%E8%83%BDBI%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%94%EF%BC%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p> 今天主要是新增了后端的线程池。利用线程池来限制BI项目用户生成AI图表的频率。也就是异步化业务</p><h3 id="异步化任务"><a href="#异步化任务" class="headerlink" title="异步化任务:"></a>异步化任务:</h3><p>​    通过异步操作让需要等待时间长的请求可以异步去完成。比如智能生成图表，如果是同步要等Ai返回则需要等上好久，用户就不能去做其他事情了。此时需要异步化：当用户提交需求时，直接返回已经收到任务结果。但是任务是否正在做需要后端自行解决。</p><h4 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h4><p>​        优化了用户的体验（不需要一直等待）。</p><p>​        对于频繁的请求会有限制。(如果没有限制可能会有的问题，那么如果同时来了10几个或者上百个任务，那么调用AI接口会导致第三方API平台直接拒绝你的访问)。</p><h4 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h4><p>​    <strong>用户发送异步请求-&gt;后端-&gt;保存到数据库-&gt;发送到队列-&gt;能处理直接处理返回结果-&gt;不能处理但能入队(没有超过队伍数量最大值)然后等待处理返回结果-&gt;不能入队其他方法(生成失败)；</strong></p><h3 id="使用线程池来完成异步化"><a href="#使用线程池来完成异步化" class="headerlink" title="使用线程池来完成异步化"></a>使用线程池来完成异步化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPoolExecutor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">            <span class="comment">//初始线程数</span></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//当线程池需要创建线程时就会调用newThread方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(<span class="meta">@NotNull</span> Runnable r)</span> &#123;</span><br><span class="line">                <span class="comment">//创建一个线程</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                <span class="comment">//设置线程名字</span></span><br><span class="line">                thread.setName(<span class="string">&quot;线程&quot;</span>+count);</span><br><span class="line">                <span class="comment">//线程数量增加</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建一个新的线程池</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * @Author: ZH</span></span><br><span class="line"><span class="comment">        * 核心线程数量，最大线程数量，线程存活时间，时间单位,工作队列,线程工厂(管理线程)</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">100</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>),threadFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> threadPoolExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这里使用的时java自带的线程池。给他注册上@bean 并配置</p><p>ThreadPoolExecutor（）中四个参数分别为：核心线程数量，最大线程数量，线程存活时间，时间单位，工作队列，消息工厂。还有一个拒绝策略的参数</p><h4 id="核心线程数量："><a href="#核心线程数量：" class="headerlink" title="核心线程数量："></a>核心线程数量：</h4><p>​    相当于正式员工，有活了都是先给他们干。</p><h4 id="最大线程数量："><a href="#最大线程数量：" class="headerlink" title="最大线程数量："></a>最大线程数量：</h4><p>​    相当于临时工，只有忙不过来的时候才招募（队列满了）</p><h4 id="线程存活时间"><a href="#线程存活时间" class="headerlink" title="线程存活时间:"></a>线程存活时间:</h4><p>​    当用上了最大线程数量时等待请求数量减少到不需要这些临时工时就给他删去。也就是零时工多久没干活了就给它删了</p><h4 id="工作队列："><a href="#工作队列：" class="headerlink" title="工作队列："></a>工作队列：</h4><p>​    队列存储着要等待的任务，所以要设置队列大小。</p><h4 id="消息工厂："><a href="#消息工厂：" class="headerlink" title="消息工厂："></a>消息工厂：</h4><p>​    负责控制每个线程的生成，这里自己新写了一个</p><h4 id="拒绝策略："><a href="#拒绝策略：" class="headerlink" title="拒绝策略："></a>拒绝策略：</h4><p>​    如果队列满了被拒绝要进行的操作</p><h4 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h4><p>​    当任务进入这个线程池 如果 此时核心数量还有空闲那么直接分配给核心。 如果核心数量满了则进入工作队列。如果工作也满了那么就去申请额外的线程保证总数量不超过最大线程数量。要是最大线程数量也满了那么就被拒绝。</p><blockquote><p>一般情况下，任务分为 10 密集型和计算密集型两种。计算密集型:吃 CPU，比如音视频处理、图像处理、数学计算等，一般是设置 corePoolSize 为CPU 的核数+1(空余线程)，可以让每个线程都能利用好 CPU 的每个核，而且线程之间不用频繁切换(减少打架、减少开销)<br> 10 密集型:吃带宽&#x2F;内存&#x2F;硬盘的读写资源，corePoolSize 可以设置大一点，一般经验值是 2n 左右，但是建议以 10 的能力为主。</p><h4 id="—by-yupi"><a href="#—by-yupi" class="headerlink" title="—by yupi"></a>—by yupi</h4></blockquote><h3 id="测试接口"><a href="#测试接口" class="headerlink" title="测试接口"></a>测试接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/queue&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;,&quot;local&quot;&#125;)</span> <span class="comment">//只在本地测试环境生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="comment">// 自动注入一个线程池的实例</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="comment">// 接收一个参数name，然后将任务添加到线程池中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用CompletableFuture运行一个异步任务</span></span><br><span class="line">        CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 打印一条日志信息，包括任务名称和执行线程的名称</span></span><br><span class="line">            log.info(<span class="string">&quot;任务执行中：&quot;</span> + name + <span class="string">&quot;，执行人：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 让线程休眠10分钟，模拟长时间运行的任务</span></span><br><span class="line">                Thread.sleep(<span class="number">60000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 异步任务在threadPoolExecutor中执行</span></span><br><span class="line">        &#125;, threadPoolExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="comment">// 该方法返回线程池的状态信息</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个HashMap存储线程池的状态信息</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 获取线程池的队列长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> threadPoolExecutor.getQueue().size();</span><br><span class="line">        <span class="comment">// 将队列长度放入map中</span></span><br><span class="line">        map.put(<span class="string">&quot;队列长度&quot;</span>, size);</span><br><span class="line">        <span class="comment">// 获取线程池已接收的任务总数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">taskCount</span> <span class="operator">=</span> threadPoolExecutor.getTaskCount();</span><br><span class="line">        <span class="comment">// 将任务总数放入map中</span></span><br><span class="line">        map.put(<span class="string">&quot;任务总数&quot;</span>, taskCount);</span><br><span class="line">        <span class="comment">// 获取线程池已完成的任务数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">completedTaskCount</span> <span class="operator">=</span> threadPoolExecutor.getCompletedTaskCount();</span><br><span class="line">        <span class="comment">// 将已完成的任务数放入map中</span></span><br><span class="line">        map.put(<span class="string">&quot;已完成任务数&quot;</span>, completedTaskCount);</span><br><span class="line">        <span class="comment">// 获取线程池中正在执行任务的线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">activeCount</span> <span class="operator">=</span> threadPoolExecutor.getActiveCount();</span><br><span class="line">        <span class="comment">// 将正在工作的线程数放入map中</span></span><br><span class="line">        map.put(<span class="string">&quot;正在工作的线程数&quot;</span>, activeCount);</span><br><span class="line">        <span class="comment">// 将map转换为JSON字符串并返回</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toJsonStr(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DeepSeekResponseVO <span class="title function_">genChartByAiAsync</span><span class="params">(MultipartFile multipartFile, GenChartByAiRequest genChartByAiRequest, User loginUser)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> genChartByAiRequest.getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">goal</span> <span class="operator">=</span> genChartByAiRequest.getGoal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">chartType</span> <span class="operator">=</span> genChartByAiRequest.getChartType();</span><br><span class="line">        <span class="comment">//用户输入</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">userInput</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userGoal</span> <span class="operator">=</span> goal;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotBlank(chartType))&#123;</span><br><span class="line">            userGoal+=<span class="string">&quot;请使用&quot;</span>+chartType;</span><br><span class="line">        &#125;</span><br><span class="line">        userInput.append(<span class="string">&quot;分析需求:&quot;</span>).append(userGoal).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">csvData</span> <span class="operator">=</span> ExcelUtils.excelToCsv(multipartFile);</span><br><span class="line">        userInput.append(<span class="string">&quot;原始目标:&quot;</span>).append(csvData).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存Chart</span></span><br><span class="line">        <span class="type">Chart</span> <span class="variable">chart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chart</span>();</span><br><span class="line">        chart.setGoal(goal);</span><br><span class="line">        chart.setName(name);</span><br><span class="line">        chart.setChartType(chartType);</span><br><span class="line">        <span class="comment">//先不返回</span></span><br><span class="line"><span class="comment">//        chart.setGenChart(genChart);</span></span><br><span class="line"><span class="comment">//        chart.setGenResult(genResult);</span></span><br><span class="line">        chart.setUserId(loginUser.getId());</span><br><span class="line">        <span class="comment">//设置为排队</span></span><br><span class="line">        chart.setStatus(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">saveResult</span> <span class="operator">=</span> <span class="built_in">this</span>.save(chart);</span><br><span class="line">        ThrowUtils.throwIf(!saveResult, ErrorCode.SYSTEM_ERROR, <span class="string">&quot;图表保存失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建ChartData表Sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">chartDataTableSql</span> <span class="operator">=</span> ChartTableUtils.ChartDataToTableSql(csvData,chart.getId());</span><br><span class="line">        <span class="comment">//防止sql注入</span></span><br><span class="line">        ThrowUtils.throwIf(SqlUtils.validSortField(chartDataTableSql),ErrorCode.PARAMS_ERROR,<span class="string">&quot;创建chartData表非法&quot;</span>);</span><br><span class="line">        <span class="comment">//创建表</span></span><br><span class="line">        chartMapper.createChartDataTable(chartDataTableSql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入CharData数据Sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">chartDataValueSql</span> <span class="operator">=</span> ChartTableUtils.ChartDataInsertTableSql(csvData,chart.getId());</span><br><span class="line">        <span class="comment">//防止sql注入</span></span><br><span class="line">        ThrowUtils.throwIf(SqlUtils.validSortField(chartDataValueSql),ErrorCode.PARAMS_ERROR,<span class="string">&quot;插入chartData数据非法&quot;</span>);</span><br><span class="line">        <span class="comment">//插入数据</span></span><br><span class="line">        chartMapper.insertChartData(chartDataValueSql);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步处理</span></span><br><span class="line">        <span class="comment">//使用deepseek获取结果</span></span><br><span class="line">        CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//更新Chart数据库的Status 状态。从wait-&gt;running</span></span><br><span class="line">            <span class="type">Chart</span> <span class="variable">updatingChart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chart</span>();</span><br><span class="line">            updatingChart.setId(chart.getId());</span><br><span class="line">            <span class="comment">//修改状态</span></span><br><span class="line">            updatingChart.setStatus(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">updateStatusResult</span> <span class="operator">=</span> <span class="built_in">this</span>.updateById(updatingChart);</span><br><span class="line">            <span class="keyword">if</span>(!updateStatusResult)&#123;</span><br><span class="line">                handleChartUpdateError(chart.getId(),<span class="string">&quot;更新图表执行中状态失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> deepSeekService.callDeepSeek(userInput.toString());</span><br><span class="line">            String[] split = result.split(<span class="string">&quot;【【【【【&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(split.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">               handleChartUpdateError(chart.getId(),<span class="string">&quot;AI 生成错误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">genChart</span> <span class="operator">=</span> split[<span class="number">1</span>].trim();</span><br><span class="line">            <span class="type">String</span> <span class="variable">genResult</span> <span class="operator">=</span> split[<span class="number">2</span>].trim();</span><br><span class="line">            <span class="comment">//得到结果后，再更新一次</span></span><br><span class="line">            <span class="type">Chart</span> <span class="variable">updateChartResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chart</span>();</span><br><span class="line">            updateChartResult.setId(chart.getId());</span><br><span class="line">            updateChartResult.setStatus(<span class="string">&quot;succeed&quot;</span>);</span><br><span class="line">            updateChartResult.setGenChart(genChart);</span><br><span class="line">            updateChartResult.setGenResult(genResult);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">updateResult</span> <span class="operator">=</span> <span class="built_in">this</span>.updateById(updateChartResult);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!updateResult)&#123;</span><br><span class="line">                handleChartUpdateError(chart.getId(),<span class="string">&quot;更新图表成功状态失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//返回VO结果</span></span><br><span class="line">        <span class="type">DeepSeekResponseVO</span>  <span class="variable">deepSeekResponseVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeepSeekResponseVO</span>();</span><br><span class="line">        deepSeekResponseVO.setChartId(chart.getId());</span><br><span class="line"><span class="comment">//        deepSeekResponseVO.setGenChart(chart.getGenChart());</span></span><br><span class="line"><span class="comment">//        deepSeekResponseVO.setGenResult(chart.getGenResult());</span></span><br><span class="line">        <span class="keyword">return</span> deepSeekResponseVO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleChartUpdateError</span><span class="params">(<span class="type">long</span> chartId,String execMessage)</span>&#123;</span><br><span class="line">        <span class="type">Chart</span> <span class="variable">updateChart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chart</span>();</span><br><span class="line">        updateChart.setId(chartId);</span><br><span class="line">        updateChart.setExecMessage(execMessage);</span><br><span class="line">        updateChart.setStatus(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">this</span>.updateById(updateChart);</span><br><span class="line">        ThrowUtils.throwIf(!result,ErrorCode.SYSTEM_ERROR,<span class="string">&quot;保存Chart执行消息失败&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;更新图表失败 &quot;</span>+chartId+ <span class="string">&quot; &quot;</span>+execMessage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO:"></a>TODO:</h3><p>​    \1. 当线程空闲时应该把被拒绝的请求完成。</p><p>​    \2. 超时控制，增加一个超时时间，如果超过这个时间则标记为失败。</p><p>​    3.反向压力：（通过AI服务当前任务队列数来控制核心数量）最大化利用资源<a href="https://zhuanlan.zhihu.com/p/404993753">反向压力 - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 智能BI项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 线程池 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 异步化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能BI项目（四）分表和限流(令牌桶算法)</title>
      <link href="/2025/07/14/%E6%99%BA%E8%83%BDBI%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%86%E8%A1%A8%E5%92%8C%E9%99%90%E6%B5%81-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2025/07/14/%E6%99%BA%E8%83%BDBI%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%86%E8%A1%A8%E5%92%8C%E9%99%90%E6%B5%81-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>​    没什么好说的就是新增了一个浏览我的图表的页面</p><p><img src="/images/pasted-10.png" alt="upload successful"></p><h2 id="后端："><a href="#后端：" class="headerlink" title="后端："></a>后端：</h2><h3 id="分表设计"><a href="#分表设计" class="headerlink" title="分表设计!!"></a>分表设计!!</h3><p><img src="/images/pasted-11.png" alt="upload successful"></p><p>原来这个分表的设计有个从csv里的数据得到的chartData字段。但是这个东西数据量大起来就会很影响查询速度。所以把chartData分出来一个表<br> 每一个chartData都有一个chart_data_{charDataId}</p><p><img src="/images/pasted-12.png" alt="upload successful"></p><h3 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h3><h3 id><a href="#" class="headerlink" title></a></h3><p>​    \1. 如果需要data数据的某一行可以快速找到。</p><p>​    2.加快chart表的查询速度。互不影响增加安全性</p><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><p>​    总共有三部分 创造动态新表，向新表插入数据，查询新表数据。</p><p><img src="/images/pasted-13.png" alt="upload successful"></p><p>直接用sql语句。(但是要小心sql注入需要校验一下)</p><h3 id="限流：面试必备：4种经典限流算法讲解最近我们系统引入了Guava的RateLimiter限流组件，它是基于令牌桶算法的实现的。-掘金"><a href="#限流：面试必备：4种经典限流算法讲解最近我们系统引入了Guava的RateLimiter限流组件，它是基于令牌桶算法的实现的。-掘金" class="headerlink" title="限流：面试必备：4种经典限流算法讲解最近我们系统引入了Guava的RateLimiter限流组件，它是基于令牌桶算法的实现的。 - 掘金"></a>限流：<a href="https://juejin.cn/post/6967742960540581918">面试必备：4种经典限流算法讲解最近我们系统引入了Guava的RateLimiter限流组件，它是基于令牌桶算法的实现的。 - 掘金</a></h3><p> 防止用户频繁操作。限制用户每分钟发送请求的次数。</p><p> 使用Redisson自带的限流方案</p><p><img src="/images/pasted-14.png" alt="upload successful"></p><h1 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h1><p>Redisson<strong>实现****令牌桶算法(trySetRate)</strong>。<br> 相当于<br> 有一个大鞋柜，大鞋柜里每个格子放了一双鞋子。<br> 当学生过来拿鞋子，会判断有没有柜子有没有鞋子，有的话就拿走。只有拿到鞋子的用户才有资格进入教室，没有拿到的不行。<br> 会有人一某种速率补充鞋子进鞋柜。比如一分钟补充5双直到补满。</p>]]></content>
      
      
      <categories>
          
          <category> 智能BI项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 令牌桶算法 </tag>
            
            <tag> 分表 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能BI项目（二）前端登录和后端处理excel</title>
      <link href="/2025/07/14/%E6%99%BA%E8%83%BDBI%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89%E5%89%8D%E7%AB%AF%E7%99%BB%E5%BD%95%E5%92%8C%E5%90%8E%E7%AB%AF%E5%A4%84%E7%90%86excel/"/>
      <url>/2025/07/14/%E6%99%BA%E8%83%BDBI%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89%E5%89%8D%E7%AB%AF%E7%99%BB%E5%BD%95%E5%92%8C%E5%90%8E%E7%AB%AF%E5%A4%84%E7%90%86excel/</url>
      
        <content type="html"><![CDATA[<p>​<br>前端没什么好说的就是改几个图标文字什么的改成自己的。把请求登录时的数据前后端对应好就行。</p><p>后端使用了</p><p>MultipartFile去读取文件。</p><p>用</p><p>EasyExcel将xlsx转成List&lt;Map&lt;&gt;&gt;;EasyExcel实现Excel文件导入导出_easyexcel导出excel-CSDN博客</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 智能BI项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EasyExcel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能BI项目（一） 初始化前后端</title>
      <link href="/2025/07/14/%E6%99%BA%E8%83%BDBI%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%89%8D%E5%90%8E%E7%AB%AF/"/>
      <url>/2025/07/14/%E6%99%BA%E8%83%BDBI%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%89%8D%E5%90%8E%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<p>跟着yupi开始学习新项目。<br> 搞这个初始化项目就搞了一晚上。折腾死了</p><p> BI项目– 根据传入的数据前端生成图表。加个智能其实也就是用ai更方便用户。提高效率。</p><h2 id="技术栈："><a href="#技术栈：" class="headerlink" title="技术栈："></a>技术栈：</h2><h5 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h5><ol><li><h5 id="react"><a href="#react" class="headerlink" title="react"></a>react</h5></li><li><h5 id="开发框架：Umi-AntDesign-Pro"><a href="#开发框架：Umi-AntDesign-Pro" class="headerlink" title="开发框架：Umi + AntDesign Pro"></a>开发框架：Umi + AntDesign Pro</h5></li><li><p>​     可视化开发库（Echarts + HighCharts +AntV）</p></li><li><p>​    umi OpeanApi (自动生成后端API接口代码。利用后端的swagger</p></li></ol><h4 id="后端："><a href="#后端：" class="headerlink" title="后端："></a>后端：</h4><ol><li>spring boot(用模板开发省时省力)</li><li>MySQL</li><li>MyBatis Plus</li><li>RabbitMQ</li><li>AI 接口</li><li>Excel上传和解析(Easy Excel)</li><li>Swagger + Knife4j (项目接口文档)</li><li>Hutool工具库</li></ol><h2 id="前端快速开始-：开始使用-Ant-Design-Pro"><a href="#前端快速开始-：开始使用-Ant-Design-Pro" class="headerlink" title="前端快速开始 ：开始使用 - Ant Design Pro"></a>前端快速开始 ：<a href="https://pro.ant.design/zh-CN/docs/getting-started/">开始使用 - Ant Design Pro</a></h2><h2 id="后端快速开始：使用yupi的模板。"><a href="#后端快速开始：使用yupi的模板。" class="headerlink" title="后端快速开始：使用yupi的模板。"></a>后端快速开始：使用yupi的模板。</h2><h2 id="初始化过程中学到了：前端快速开始和前端可以使用openAPI-结合-swagger来快速生成调用接口方法。"><a href="#初始化过程中学到了：前端快速开始和前端可以使用openAPI-结合-swagger来快速生成调用接口方法。" class="headerlink" title="初始化过程中学到了：前端快速开始和前端可以使用openAPI 结合 swagger来快速生成调用接口方法。"></a>初始化过程中学到了：前端快速开始和前端可以使用openAPI 结合 swagger来快速生成调用接口方法。</h2>]]></content>
      
      
      <categories>
          
          <category> 智能BI项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> init </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伙伴匹配系统(七) 分布式锁 Redisson 和看门狗机制</title>
      <link href="/2025/07/14/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F-%E4%B8%83-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redisson-%E5%92%8C%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/07/14/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F-%E4%B8%83-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-Redisson-%E5%92%8C%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p> 在多机环境下要想控制某段程序所需要的执行机子需要给定义一个或者多个锁。来让不同的机子去抢锁只有抢到锁的程序才执行。例如定时任务插入数据，如果没有锁那么原本只需要插入100条数据在3台服务器上就会插入300条。</p><p>方法类似于多线程的Lock但是多线程实在本地一台服务器执行，分布式锁是在多台服务器执行。本地一台的Lock无法被其他的服务器识别到</p><p>解决方法：用数据库设置一个字段例如lock,当一个程序进入判断这个字段是否为空，如果为空那么就填入字段执行完毕后释放。</p><h1 id="用Redis实现"><a href="#用Redis实现" class="headerlink" title="用Redis实现"></a>用Redis实现</h1><p>注意事项:</p><p>1.用完锁要释放</p><p>2.锁要加过期时间（如果程序异常终止了，那么字段就会一直存在）。</p><p>3.如果方法执行时间太长超过了锁设置的过期时间</p><p>​    问题：</p><p>​    1.提前释放之后下一个服务提前进来,但程序还未执行结束.</p><p>​    2.连锁效应：第二个方法进来运行时第一个方法执行结束delete了锁此时锁的value为空，第        三个服务也进来了。</p><p>​     解决方案：</p><p>​    续期 ：在方法执行过程中给其续期。</p><p> 4.释放锁时，会先判断是否为自己的锁，再进行删除，但是判断完是否是自己的锁时锁过期，此时再进来一个B方法的锁，执行delete方法会把B删除。</p><p>​    解决方法：使用原子操作：Redis+lua脚本。</p><p>可以使用Redisson解决以上问题</p><h1 id="Redisson-实现分布锁"><a href="#Redisson-实现分布锁" class="headerlink" title="Redisson 实现分布锁"></a>Redisson 实现分布锁</h1><p><strong>Redisson 是一个java操作redis的客户端，提供了大量的分布式数据集来简化对Redis的操作和使用，让开发者像使用本地集合一样使用Redis，完全感受不到Redis存在</strong></p><p>Redisson配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@className</span>: RedissonConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: ZH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/1 16:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisAddress</span> <span class="operator">=</span> String.format(<span class="string">&quot;redis://%s:%s&quot;</span>, host, port);</span><br><span class="line">        config.useSingleServer().setAddress(redisAddress).setDatabase(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// Sync and Async API</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id><a href="#" class="headerlink" title></a></h1><h1 id="看门狗-—watch-dog"><a href="#看门狗-—watch-dog" class="headerlink" title="看门狗 —watch dog"></a>看门狗 —watch dog</h1><p>redisson解决了程序运行时间过长导致value过期问题，利用watch dog看门狗机制隔一段时间重新生成一段新的锁</p><p><a href="https://blog.csdn.net/m0_56088675/article/details/143817678">Redisson 的 Watch Dog机制_redisson 检查锁的间隔-CSDN博客</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 25 * * * *&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doCacheRecommendUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;zh:preCacheJob:doCache:lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/*-1代表releasetime 默认30s时效每隔10s检测一次检测到还在执行就重置回30s如果加了时间，那么他不会自动刷新*/</span></span><br><span class="line">            <span class="keyword">if</span>(lock.tryLock(<span class="number">0</span>,-<span class="number">1</span>,TimeUnit.MILLISECONDS))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;定时任务执行&quot;</span>);</span><br><span class="line">               <span class="comment">// sleep(1000000);</span></span><br><span class="line">                importantUserIds.forEach(id-&gt;&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">String</span> <span class="variable">strKey</span> <span class="operator">=</span> String.format(<span class="string">&quot;user:recommend:%d&quot;</span>,id);</span><br><span class="line">                    <span class="type">ValueOperations</span> <span class="variable">valueOperations</span> <span class="operator">=</span> redisTemplate.opsForValue();</span><br><span class="line">                    <span class="type">QueryWrapper</span> <span class="variable">queryWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">                    Page&lt;User&gt; userList1 = (Page&lt;User&gt;) userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;( <span class="number">1</span>,<span class="number">20</span>),queryWrapper);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        valueOperations.set(strKey,userList1,<span class="number">300000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;redis存储失败&quot;</span>,e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;doCacheRecommendUser error:&quot;</span>,e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放自己的锁</span></span><br><span class="line">            <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
      
      
      <categories>
          
          <category> 伙伴匹配系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> redis </tag>
            
            <tag> redisson </tag>
            
            <tag> 看门狗机制 </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伙伴匹配系统(六)（多线程并发）</title>
      <link href="/2025/07/14/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F-%E5%85%AD-%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/"/>
      <url>/2025/07/14/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F-%E5%85%AD-%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h1><p><a href="https://liaoxuefeng.com/books/java/threading/index.html">多线程 - Java教程 - 廖雪峰的官方网站</a></p><p>在批量插入假用户的时候需要插入1000条数据，通过for循环线性插入时间效率太低了。</p><p>所以引入多线程来实现并发。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Service.saveBatch(userList,10000);</span><br></pre></td></tr></table></figure><p>在插入数据库时可以用service自带的saveBatch来实现</p><p>在创建新数据并导入时也可以用多线程去创建。</p><p>实现方法分n组去创建将每组创建得到的userList去保存到数据库。n组数据并发执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">MAX_NUMBER</span> <span class="operator">=</span> <span class="number">100000L</span>;</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    List&lt;CompletableFuture&lt;Void&gt;&gt; futureList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;User&gt; userList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//并发执行</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(()-&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; MAX_NUMBER; j++) &#123;</span><br><span class="line">                    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                    user.setUsername(<span class="string">&quot;zh&quot;</span> + j);</span><br><span class="line">                    user.setUserAccount(Long.toString(MyCommonUtils.randNumber(<span class="number">10</span>)));</span><br><span class="line">                    user.setAvatarUrl(<span class="string">&quot;../../src/img/avatar/mari.jpg&quot;</span>);</span><br><span class="line">                    user.setGender((MyCommonUtils.randNumber(<span class="number">2</span>) % <span class="number">2</span> == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">                    user.setUserPassword(<span class="string">&quot;123456789&quot;</span>);</span><br><span class="line">                    user.setPhone(Long.toString(MyCommonUtils.randNumber(<span class="number">10</span>)));</span><br><span class="line">                    user.setEmail(Long.toString(MyCommonUtils.randNumber(<span class="number">10</span>)) + <span class="string">&quot;@qq.com&quot;</span>);</span><br><span class="line">                    user.setUserStatus(<span class="number">0</span>);</span><br><span class="line">                    user.setIsDelete(<span class="number">0</span>);</span><br><span class="line">                    user.setUserRole(<span class="number">0</span>);</span><br><span class="line">                    user.setUserCode(<span class="string">&quot;123456789&quot;</span>);</span><br><span class="line">                    user.setTags(<span class="string">&quot;[]&quot;</span>);</span><br><span class="line">                    user.setProfile(<span class="string">&quot;这个人很懒&quot;</span>);</span><br><span class="line">                    userList.add(user);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                userService.saveBatch(userList,<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        futureList.add(future);</span><br><span class="line">    &#125;</span><br><span class="line">    CompletableFuture.allOf(futureList.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[]&#123;&#125;)).join();</span><br><span class="line">    stopWatch.stop();</span><br><span class="line">    System.out.println(stopWatch.getTotalTimeMillis());</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="优化"><a href="#优化" class="headerlink" title="优化-&gt;"></a>优化-&gt;</h1><p>既然能分成n组那么就可以分成n+1,n+2…n+x组所以可以利用二分的思想将其分到你想要的大小进行分块多线程并发。</p><p>用到了forkjoin</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StopWatch</span> <span class="variable">stopWatch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">stopWatch1.start();</span><br><span class="line">ForkJoinTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">AddUser</span>(<span class="number">1</span>,<span class="number">100000</span>);</span><br><span class="line">ForkJoinPool.commonPool().invoke(task);</span><br><span class="line">stopWatch1.stop();</span><br><span class="line">System.out.println(stopWatch1.getTotalTimeMillis());</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.demo.model.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.example.demo.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddUser</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AddUser addUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        addUser = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddUser</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddUser</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            List&lt;User&gt;userList = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=end-start;i++)&#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">                user.setUsername(<span class="string">&quot;zh&quot;</span>+ start+i);</span><br><span class="line">                user.setUserAccount(Long.toString(MyCommonUtils.randNumber(<span class="number">10</span>)));</span><br><span class="line">                user.setAvatarUrl(<span class="string">&quot;../../src/img/avatar/mari.jpg&quot;</span>);</span><br><span class="line">                user.setGender((MyCommonUtils.randNumber(<span class="number">2</span>)%<span class="number">2</span>==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>));</span><br><span class="line">                user.setUserPassword(<span class="string">&quot;123456789&quot;</span>);</span><br><span class="line">                user.setPhone(Long.toString(MyCommonUtils.randNumber(<span class="number">10</span>)));</span><br><span class="line">                user.setEmail(Long.toString(MyCommonUtils.randNumber(<span class="number">10</span>))+<span class="string">&quot;@qq.com&quot;</span>);</span><br><span class="line">                user.setUserStatus(<span class="number">0</span>);</span><br><span class="line">                user.setIsDelete(<span class="number">0</span>);</span><br><span class="line">                user.setUserRole(<span class="number">0</span>);</span><br><span class="line">                user.setUserCode(<span class="string">&quot;123456789&quot;</span>);</span><br><span class="line">                user.setTags(<span class="string">&quot;[]&quot;</span>);</span><br><span class="line">                user.setProfile(<span class="string">&quot;这个人很懒&quot;</span>);</span><br><span class="line">                userList.add(user);</span><br><span class="line">            &#125;</span><br><span class="line">            addUser.userService.saveBatch(userList, Math.max(userList.size()/<span class="number">10</span>,<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务太大,一分为二:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (end + start) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//        System.out.println(String.format(&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;, start, end, start, middle, middle, end));</span></span><br><span class="line">         AddUser addUser1= <span class="keyword">new</span> <span class="title class_">AddUser</span>(start, middle);</span><br><span class="line">        <span class="type">AddUser</span> <span class="variable">addUser2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddUser</span>(middle+<span class="number">1</span>, end);</span><br><span class="line">        invokeAll(addUser1, addUser2);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>线程池开启配置可以通过</p><p>public ThreadPoolExecutor(int corePoolSize,<br>                int maximumPoolSize,<br>                long keepAliveTime,<br>                TimeUnit unit,<br>                BlockingQueue<Runnable> workQueue,<br>                ThreadFactory threadFactory,<br>                RejectedExecutionHandler handler)</Runnable></p><p>去配置<a href="https://www.cnblogs.com/simpleDi/p/11342440.html">ExecutorService 线程池详解 - simpleDi - 博客园</a></p>]]></content>
      
      
      <categories>
          
          <category> 伙伴匹配系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伙伴匹配系统(五)假数据批量插入</title>
      <link href="/2025/07/14/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F-%E4%BA%94/"/>
      <url>/2025/07/14/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F-%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<p>​<br>假数据批量插入与定时任务.</p><p><img src="/images/pasted-16.png" alt="upload successful"><br>在插入批量大数据时需要开启定时任务分批次插入在springboot 启动项可以添加一个</p><p>@EnableScheduling 注解代表可以开启定时任务。<br>批量优化<br>1 可以使用myBatisplus自带的</p><p>userService.saveBatch(userList,100);<br>进行批量插入</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 伙伴匹配系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定时任务 </tag>
            
            <tag> 插入假数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伙伴匹配系统(四) 分布式登录</title>
      <link href="/2025/07/14/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F-%E5%9B%9B/"/>
      <url>/2025/07/14/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F-%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<p>​<br>Session 多机登录实现分布式登录<br> <br>Session 存储在一个domin路径下,但是调用不同的服务器不会功享保存的Session值。Session里包含了用户信息等内容所以要吧Session保存到Redis里边并让服务器从相同的Redis里去调用。实现分布式登录</p><p>Redis 安装与配置<br>5版本：Releases · tporadowski&#x2F;redis 下载.msi傻瓜式安装<br>在maven仓库中找到spring boot starter data redis  与springboot版本差不多。</p><p>可以下载quickRedis操作管理Redis</p><p>将Session传入Redis中的工具<br>在maven仓库中找到spring-session-data-redis 与springboot 差不多版本</p><p>配置xml</p><p><img src="/images/pasted-15.png" alt="upload successful"></p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 伙伴匹配系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> redis </tag>
            
            <tag> session </tag>
            
            <tag> 分布式登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伙伴匹配系统(三)(axios请求，controller注解，vue OnMounted)</title>
      <link href="/2025/07/14/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F-%E4%B8%89-axios%E8%AF%B7%E6%B1%82%EF%BC%8Ccontroller%E6%B3%A8%E8%A7%A3%EF%BC%8Cvue-OnMounted/"/>
      <url>/2025/07/14/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F-%E4%B8%89-axios%E8%AF%B7%E6%B1%82%EF%BC%8Ccontroller%E6%B3%A8%E8%A7%A3%EF%BC%8Cvue-OnMounted/</url>
      
        <content type="html"><![CDATA[<p>防盗链referer</p><p>开启防盗链可以让其他网站加载不出他的网站的图片</p><p>防盗链referer详解和解决办法_referer防盗链原理-CSDN博客</p><p>Controller层返回对象问题</p><p>传统@controller注解返回对象是视图对象<br>@ResponseBody详解-CSDN博客在方法上加个@ResponseBody的注解即可返回JSON格式或者其他类型，或者直接将@Controller换成@RestController<br>@RestController &#x3D; @ResponsBody+@Controller</p><p>前端onMounted 生命周期钩子</p><p>在vue3中的setup里生命或者调用函数这个函数会在组件初始化之前运行使用onMounted 会在组件的DOM加载完后再调用<br>Vue 3 里的 onMounted 怎么用？_vue3 onmounted-CSDN博客 </p><p>axios get请求传入数组<br>一般axios的get方法，但是传入数组会有a[]&#x3D;1&amp;a[]&#x3D;2和controller层所需要的格式不同<br>可以引入qs库可以改变他的输入方式<br>axios请求传递数组 paramsSerializer序列化-CSDN博客</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 伙伴匹配系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伙伴匹配系统(二)前端学习</title>
      <link href="/2025/07/14/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F-%E4%BA%8C-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/07/14/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F-%E4%BA%8C-%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>1.router 和 route的区别。</p><p>router 用于跳转，传参等</p><p>route用于得到数据。</p><p>2.Vue中常用的数组方法.filter()、.map()、.forEach()、.find()、.findIndex()、.some()、.every()</p><p><a href="https://blog.csdn.net/wang_xiao_ye/article/details/89385023">Vue中常用的数组方法.filter()、.map()、.forEach()、.find()、.findIndex()、.some()、.every()_vue中的a.filter()方法-CSDN博客</a></p><p>3.扩展语言a&#x3D;[…b]代表将b赋值给a，a&#x3D;[…b,..c]代表a包括了b,c</p><p>[深入理解 JavaScript 的【扩展运算符】【…】（Spread Operator）-CSDN博客](<a href="https://blog.csdn.net/jhgj56/article/details/143232852#:~:text=%E5%9C%A8">https://blog.csdn.net/jhgj56/article/details/143232852#:~:text=在</a> JavaScript 中， 扩展运算符 （…）是一种非常强大且 灵活的 语法，可以简化数组和对象的操作。 本文将详细介绍扩展运算符的基本用法、应用场景及其背后的原理。,什么是扩展运算符？ 扩展运算符（spread operator）是 ES6 （ECMAScript 2015）引入的一项特性，用于将数组或对象拆分成单独的元素或属性。 它的语法非常简单，只需在表达式前面添加三个点 …。)</p>]]></content>
      
      
      <categories>
          
          <category> 伙伴匹配系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端 </tag>
            
            <tag> route </tag>
            
            <tag> router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伙伴匹配系统后端开发(一)框架搭建</title>
      <link href="/2025/07/14/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-%E4%B8%80-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
      <url>/2025/07/14/%E4%BC%99%E4%BC%B4%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-%E4%B8%80-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>1.通过mybatisX generate 构造器去自动构造类.</p><p>\2. 学习了java enum(枚举类)<a href="https://liaoxuefeng.com/books/java/oop/core/enum/index.html">枚举类 - Java教程 - 廖雪峰的官方网站</a></p><p>可以不需要声明很多东西，减少了代码复杂度.</p><p>3学习了 throw RuntimeException (抛异常)<br> 在运行中遇到的异常如数组越界等都可以用throw RuntimeException 来处理.</p><p>4.QueryWrapper 条件构造器<a href="https://blog.csdn.net/bird_tp/article/details/105587582">mybatis plus 条件构造器queryWrapper学习_querywapper是什么-CSDN博客</a></p><p>可以直接在这里添加条件不需要再用Mapper.xml里面重新写一遍,更加的快速。</p><p>5.Gson (json字符串和类互相转换)</p><p><a href="https://blog.csdn.net/qq_40163677/article/details/112412623">Gson的基本使用_gson使用-CSDN博客</a></p><p>6.使用了<code>Optional</code>类来处理可能为<code>null的值</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tagNameSet = Optional.ofNullable(tagNameSet).orElse(new HashSet&lt;&gt;());</span><br></pre></td></tr></table></figure><p>处理这个Set是否为空的情况如果tagNameSet为null则返回Optional对象，<code>orElse</code>方法用于处理<code>tagNameSet</code>可能为<code>null</code>的情况。如果<code>tagNameSet</code>为<code>null</code>，则<code>Optional.ofNullable(tagNameSet)</code>会返回一个空的<code>Optional</code>对象，随后调用<code>orElse(new HashSet&lt;&gt;())</code>会返回一个新的<code>HashSet</code>实例作为默认值。如果不为空就将tagNameSet往里赋值。</p><p>7.List.stream().filter 将list里面的参数筛选里面可以通过写逻辑判断函数来得到想要的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return userList.stream().filter(user -&gt;&#123;</span><br><span class="line">     //条件 return false</span><br><span class="line">    return true;</span><br><span class="line">&#125;).map(this::getSafetyUser).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>.map（this::getSafetyUser）可以存到map里得到安全的safetyUser。</p><p>.collect(Collectors.toList()); 转换成list</p>]]></content>
      
      
      <categories>
          
          <category> 伙伴匹配系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> init </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/07/11/hello-world/"/>
      <url>/2025/07/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start1"><a href="#Quick-Start1" class="headerlink" title="Quick Start1"></a>Quick Start1</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
